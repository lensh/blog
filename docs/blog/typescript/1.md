# typescript基础
TypeScript本质上是向JavaScript语言添加了可选的静态类型和基于类的面向对象编程，同时也支持诸如接口、命名空间、装饰器等特性，它相当于是JavaScript的超集。
作用：
* 1、类型检查。
* 2、避免低级错误。
* 3、解放劳动力。
* 4、帮助我们写出更高质量的代码。
* 5、类型推演与类型匹配。
* 6、包含js最新特性。
## 一、typescript的类型
* 基础类型：boolean、string、null、undefined、array、object、number、tuple、enum、void、never、any。
* 高级类型：union组合类型、Nullable可空类型、Literal预定义类型
### 1、数组
```js
let arr: number[] = [1, 2, 4, 4, 4]
let arr1: Array<number> = [1, 2, 44, 5, 5]
```
### 2、元组tuple
元组是固定长度、固定类型的数组，申明的时候需要指明数据类型。
```js
let arr2: [number, string] = [1, "zls"] // 元组
```
### 3、联合(Union)与字面量(Literal)类型
联合类型：一个变量可以同时支持多个不同数据类型
```js
let str: string | number = 'zls'
```
字面量类型：指定具体的值
```js
let str1: 1 | 'zls' | true | [1, 2, 3, 4]
```
### 4、枚举类型
```js
enum Color {
    red,
    green
}

let color = Color.green
console.log(color) // 1 输出的是索引值

enum Color1 {
    red = 'ssss',
    green = 'zls'
}

let color1 = Color1.green
console.log(color1) // zls 输出具体的值
```
### 5、any 与 unknow
两者的区别：

可以将任何东西赋给 unknown 类型，但在进行类型检查或类型断言之前，不能对 unknown 进行操作。

可以把任何东西分配给any类型，也可以对any类型进行任何操作。

* unknown 示例：
```js
function invokeAnything(callback: unknown) {
  // 可以将任何东西赋给 `unknown` 类型，
  // 但在进行类型检查或类型断言之前，不能对 `unknown` 进行操作
  if (typeof callback === 'function') {
    callback();
  }
}

invokeAnything(1); // You can assign anything to `unknown` type
```
类型检查 typeof callback === 'function'，检查 callback 是否为函数，如果是，则可以调用。

* any 示例：
```js
function invokeAnything(callback: any) {
  // 可以对 `any` 类型执行任何操作
  callback();
}

invokeAnything(1); // 可以把任何东西分配给`any`类型
```
如果 callback是 any, TypeScript 就不会强制 callback() 语句进行任何类型检查。
### 6、 void、undefined 与 Never
void是指没有返回值的类型，
```js
function printR(): void {
    console.log('ddd')
}
console.log(printR())  // undefined
```
never，代表永远执行不完
```ts
function throwError(message: string, code: number): never {
    throw {
        message,
        code
    }
}
throwError('sd', 404)
```
### 7、类型适配 Type Assertions
```ts
let message: any; // 这里申明了any类型
message = 'abc';
message.endsWith('c'); // 调用endsWith的时候，不会自动联想endsWith这个方法，因为是any类型，不是字符串

let str1 = (<string>message).endsWith('c');   // (<string>message)  将any类型适配成了string类型

let str2 = (message as string).endsWith('c');  // 或者用(message as string) 进行适配
```
## 二、ts面向对象
### 1、class和interface
```ts
interface Ipoint {
    x: number;
    y: number;
    drawPoint: () => void;
}

class Point implements Ipoint {
    x: number;
    y: number;
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
    drawPoint = () => {
        console.log(this.x, this.y);
    }
}
```
### 2、访问修饰符
public 表示公有的属性或者方法，private 表示私有的属性或者方法。
```ts
class Point1 implements Ipoint {
    constructor(public x: number, public y: number) {}
    drawPoint = () => {
        console.log(this.x, this.y);
    }
}
```
### 3、Generics 泛型
泛型T，代表传入什么类型，就输出什么类型，让编译器自己判断类型，保持类型的一致性
```ts
let lastInArray = <T>(arr: Array<T>) => {
    return arr[arr.length - 1]
}

const l1 = lastInArray([1, 2, 3, 5])
const l2 = lastInArray(["a", "b", "c"])
```
多泛型
```ts
let makeTuple = <T, K>(x: T, y: K) => [x, y]
const v1 = makeTuple(1, 'zls')
const v2 = makeTuple<boolean, number>(true, 1)
```