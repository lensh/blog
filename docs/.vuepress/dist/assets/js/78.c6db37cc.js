(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{492:function(t,a,s){"use strict";s.r(a);var r=s(62),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"http2-0、http3-0、https"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http2-0、http3-0、https"}},[t._v("#")]),t._v(" http2.0、http3.0、https")]),t._v(" "),s("h2",{attrs:{id:"一、http2-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、http2-0"}},[t._v("#")]),t._v(" 一、http2.0")]),t._v(" "),s("h3",{attrs:{id:"概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),s("p",[t._v("HTTP/2 是HTTP协议的第二个主要版本，主要基于"),s("code",[t._v("SPDY协议")]),t._v("。HTTP2.0的特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大幅度提高了web性能。")]),t._v(" "),s("h3",{attrs:{id:"什么是spdy协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是spdy协议"}},[t._v("#")]),t._v(" 什么是SPDY协议")]),t._v(" "),s("p",[s("code",[t._v("SPDY协议")]),t._v("是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。")]),t._v(" "),s("h3",{attrs:{id:"http1-x的缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http1-x的缺点"}},[t._v("#")]),t._v(" HTTP1.x的缺点")]),t._v(" "),s("ul",[s("li",[t._v("HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。")]),t._v(" "),s("li",[t._v("单向请求，只能由客户端发起。")]),t._v(" "),s("li",[t._v("请求报文与响应报文首部信息冗余量大。")]),t._v(" "),s("li",[t._v("数据未压缩，导致数据的传输量大。")])]),t._v(" "),s("p",[t._v("我们可以通过一个链接来对比一下HTTP2.0到底比HTTP1.x快了多少。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://pic4.zhimg.com/v2-4941fe9fd2f9eadcdc47932598c420e3_b.webp",alt:"image"}})]),t._v(" "),s("h3",{attrs:{id:"http2-0的优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http2-0的优点"}},[t._v("#")]),t._v(" HTTP2.0的优点")]),t._v(" "),s("h4",{attrs:{id:"_1-二进制传输"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-二进制传输"}},[t._v("#")]),t._v(" （1）二进制传输")]),t._v(" "),s("p",[t._v("HTTP2.0中所有加强性能的核心是二进制传输，在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。\n在HTTP2.0中引入了二进制格式编码机制，所有传输的数据都会被分割，并采用二进制格式编码。\n"),s("img",{attrs:{src:"https://image-static.segmentfault.com/255/492/2554926774-5b8e41d288514_articlex",alt:"image"}})]),t._v(" "),s("p",[t._v("为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。")]),t._v(" "),s("h4",{attrs:{id:"_2-多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-多路复用"}},[t._v("#")]),t._v(" （2）多路复用")]),t._v(" "),s("p",[t._v("在HTTP1.0中，我们经常会使用到雪碧图、使用多个域名等方式来进行优化，都是因为浏览器限制了同一个域名下的请求数量，当页面需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求时，资源需要等待其他资源请求完成后才能继续发送。\nHTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。\n帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。\n所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的标识知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://image-static.segmentfault.com/145/296/1452964433-5b8e41d284282_articlex",alt:"image"}})]),t._v(" "),s("p",[t._v("多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。")]),t._v(" "),s("h4",{attrs:{id:"_3-header压缩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-header压缩"}},[t._v("#")]),t._v(" （3）Header压缩")]),t._v(" "),s("p",[t._v("在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。\n在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。")]),t._v(" "),s("h4",{attrs:{id:"_4-服务器push"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-服务器push"}},[t._v("#")]),t._v(" （4）服务器Push")]),t._v(" "),s("p",[t._v("在HTTP2.0中，服务端可以在客户端某个请求后，主动推送其他资源。\n可以想象一下，某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，就可以相对减少一点延迟时间。在浏览器兼容的情况下也可以使用prefetch。")]),t._v(" "),s("h4",{attrs:{id:"_5-更安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-更安全"}},[t._v("#")]),t._v(" （5）更安全")]),t._v(" "),s("p",[t._v("HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。")]),t._v(" "),s("h2",{attrs:{id:"二、http3-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、http3-0"}},[t._v("#")]),t._v(" 二、http3.0")]),t._v(" "),s("p",[t._v("HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。因为在出现丢包的情况下，整个TCP都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1来说，可以开启多个TCP连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。")]),t._v(" "),s("p",[t._v("基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。")]),t._v(" "),s("h3",{attrs:{id:"多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),s("p",[t._v("虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。")]),t._v(" "),s("p",[t._v("并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。")]),t._v(" "),s("h3",{attrs:{id:"_0-rtt"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0-rtt"}},[t._v("#")]),t._v(" 0-RTT")]),t._v(" "),s("p",[t._v("通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。")]),t._v(" "),s("h3",{attrs:{id:"纠错机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#纠错机制"}},[t._v("#")]),t._v(" 纠错机制")]),t._v(" "),s("p",[t._v("假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。")]),t._v(" "),s("p",[t._v("当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。")]),t._v(" "),s("h2",{attrs:{id:"三、https"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、https"}},[t._v("#")]),t._v(" 三、https")]),t._v(" "),s("p",[t._v("HTTPS在传统的HTTP和TCP之间加了一层用于加密解密的SSL/TLS层。使用HTTPS必须要有一套自己的数字证书（包含公钥和私钥）。")]),t._v(" "),s("p",[t._v("HTTPS解决的问题")]),t._v(" "),s("ul",[s("li",[t._v("信息加密传输：第三方无法窃听")]),t._v(" "),s("li",[t._v("完整性校验：一旦被篡改，通信双方会立刻发现")]),t._v(" "),s("li",[t._v("身份认证：防止身份被冒充")])]),t._v(" "),s("p",[t._v("HTTPS加密过程：")]),t._v(" "),s("p",[s("img",{attrs:{src:"/blog/images/https.png",alt:"image"}})]),t._v(" "),s("p",[s("strong",[t._v("加密过程使用了对称加密和非对称加密。在交换密钥阶段使用非对称加密方式，之后建立通信交换报文阶段则使用对称加密。")])]),t._v(" "),s("h3",{attrs:{id:"非对称加密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[t._v("#")]),t._v(" 非对称加密")]),t._v(" "),s("p",[t._v("客户端通过公钥加密。服务端通过私钥解密.")]),t._v(" "),s("p",[t._v("非对称加密密使用一对非对称的密钥。一把叫做公钥，一把叫做私钥。私钥不能让其他任何人知道，而公钥则可以随意发布，任何人都可以获得。使用此加密方式，发送密文的一方使用公钥进行加密处理，对方收到被加密的信息后，再使用自己的私钥进行解密。利用这种方式，不需要发送用来解密的私钥，也不必担心密钥被攻击者窃听盗走。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("encrypt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("明文，公钥"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" 密文\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("decrypt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("密文，私钥"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" 明文\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("由于非对称加密比对称加密要慢，所以我们就需要综合一下他们两者的优缺点，使他们共同使用，而这也是HTTPS采用的加密方式。")]),t._v(" "),s("h3",{attrs:{id:"对称加密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对称加密"}},[t._v("#")]),t._v(" 对称加密")]),t._v(" "),s("p",[t._v("客户端和服务端采用相同的密钥经行加密。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("encrypt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("明文，密钥"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" 密文\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("decrypt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("密文，密钥"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" 明文\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("h3",{attrs:{id:"https-握手过程中-客户端如何验证证书的合法性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https-握手过程中-客户端如何验证证书的合法性"}},[t._v("#")]),t._v(" HTTPS 握手过程中，客户端如何验证证书的合法性")]),t._v(" "),s("ul",[s("li",[t._v("校验证书的颁发机构是否受客户端信任。")]),t._v(" "),s("li",[t._v("通过 CRL 或 OCSP 的方式校验证书是否被吊销。")]),t._v(" "),s("li",[t._v("对比系统时间，校验证书是否在有效期内。")]),t._v(" "),s("li",[t._v("通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);