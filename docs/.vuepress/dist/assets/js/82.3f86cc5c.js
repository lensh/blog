(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{496:function(a,s,t){"use strict";t.r(s);var e=t(62),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"udp和tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp和tcp"}},[a._v("#")]),a._v(" UDP和TCP")]),a._v(" "),t("p",[a._v("UDP 与 TCP 的区别是什么？")]),a._v(" "),t("p",[t("img",{attrs:{src:"/blog/images/network-7-1.png",alt:"image"}})]),a._v(" "),t("p",[a._v("首先 UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。")]),a._v(" "),t("h2",{attrs:{id:"一、udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、udp"}},[a._v("#")]),a._v(" 一、UDP")]),a._v(" "),t("h3",{attrs:{id:"面向无连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向无连接"}},[a._v("#")]),a._v(" 面向无连接")]),a._v(" "),t("p",[a._v("首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。")]),a._v(" "),t("p",[a._v("具体来说就是：在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识是 UDP 协议，然后就传递给网络层了在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。")]),a._v(" "),t("h3",{attrs:{id:"不可靠性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不可靠性"}},[a._v("#")]),a._v(" 不可靠性")]),a._v(" "),t("p",[a._v("首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。")]),a._v(" "),t("p",[a._v("再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。")]),a._v(" "),t("h3",{attrs:{id:"高效"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高效"}},[a._v("#")]),a._v(" 高效")]),a._v(" "),t("p",[a._v("虽然 UDP 协议不是那么的可靠，但是正是因为它不是那么的可靠，所以也就没有 TCP 那么复杂了，需要保证数据不丢失且有序到达。")]),a._v(" "),t("p",[a._v("因此 UDP 的头部开销小，只有八字节，相比 TCP的至少二十字节要少得多，在传输数据报文时是很高效的。")]),a._v(" "),t("h3",{attrs:{id:"适合使用的场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#适合使用的场景"}},[a._v("#")]),a._v(" 适合使用的场景")]),a._v(" "),t("p",[a._v("UDP 虽然对比 TCP 有很多缺点，但是正是因为这些缺点造就了它高效的特性，在很多实时性要求高的地方都可以看到 UDP 的身影。")]),a._v(" "),t("h2",{attrs:{id:"二、tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、tcp"}},[a._v("#")]),a._v(" 二、TCP")]),a._v(" "),t("p",[a._v("TCP 基本是和 UDP 反着来，建立连接断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 UDP 来说不那么的高效。")]),a._v(" "),t("h3",{attrs:{id:"头部"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#头部"}},[a._v("#")]),a._v(" 头部")]),a._v(" "),t("p",[a._v("对于 TCP 头部来说，以下几个字段是很重要的")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文\nAcknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到\nWindow Size，窗口大小，表示还能接收多少字节的数据，用于流量控制\n标识符\nURG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。\nACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。\nPSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。\nRST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。\nSYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。\nFIN=1：该字段为一表示此报文段是一个释放连接的请求报文。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br")])]),t("p",[a._v("滑动窗口解决了数据的丢包、顺序不对和流量控制问题。")]),a._v(" "),t("p",[a._v("拥塞窗口实现了对流量的控制，保证在全天候环境下最优的传递数据。")])])}),[],!1,null,null,null);s.default=r.exports}}]);