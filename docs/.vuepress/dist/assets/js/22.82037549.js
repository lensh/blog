(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{368:function(a,e,t){"use strict";t.r(e);var r=t(42),s=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"浏览器缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[a._v("#")]),a._v(" 浏览器缓存")]),a._v(" "),t("p",[a._v("对于web应用来说，缓存是提升页面性能同时减少服务器压力的利器。")]),a._v(" "),t("h2",{attrs:{id:"一、缓存类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、缓存类型"}},[a._v("#")]),a._v(" 一、缓存类型")]),a._v(" "),t("h3",{attrs:{id:"_1、强缓存（仅根据时间判断是否过期，没法保证是否是最新的）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、强缓存（仅根据时间判断是否过期，没法保证是否是最新的）"}},[a._v("#")]),a._v(" 1、强缓存（仅根据时间判断是否过期，没法保证是否是最新的）")]),a._v(" "),t("p",[a._v("不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache。")]),a._v(" "),t("h4",{attrs:{id:"内存缓存-from-memory-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存缓存-from-memory-cache"}},[a._v("#")]),a._v(" 内存缓存(from memory cache)")]),a._v(" "),t("p",[a._v("内存缓存具有两个特点，分别是快速读取和时效性。")]),a._v(" "),t("p",[a._v("a.快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。")]),a._v(" "),t("p",[a._v("b.时效性：一旦该进程关闭，则该进程的内存则会清空。")]),a._v(" "),t("h4",{attrs:{id:"硬盘缓存-from-disk-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#硬盘缓存-from-disk-cache"}},[a._v("#")]),a._v(" 硬盘缓存(from disk cache)")]),a._v(" "),t("p",[a._v("硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。")]),a._v(" "),t("h4",{attrs:{id:"相关header"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关header"}},[a._v("#")]),a._v(" 相关header:")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("Expires ：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。它的值为一个绝对时间的GMT格式的时间字符串， 比如Expires:Thu,21 Jan 2018 23:39:02 GMT")])]),a._v(" "),t("li",[t("p",[a._v("Cache-Control ：这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示。当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。比如Cache-Control:max-age=300，")])])]),a._v(" "),t("p",[a._v("在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：")]),a._v(" "),t("p",[t("strong",[a._v("public：所有内容都将被缓存（客户端和代理服务器都可缓存）")])]),a._v(" "),t("p",[t("strong",[a._v("private：所有内容只有客户端可以缓存，Cache-Control的默认取值")])]),a._v(" "),t("p",[t("strong",[a._v("no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定")])]),a._v(" "),t("p",[t("strong",[a._v("no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存")])]),a._v(" "),t("p",[t("strong",[a._v("max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效")])]),a._v(" "),t("p",[a._v("Cache-Control优先级高于Expires")]),a._v(" "),t("p",[a._v("简单概括：其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容较客户端是否已经发生了更新呢？此时我们需要协商缓存策略。")]),a._v(" "),t("h3",{attrs:{id:"_2、协商缓存（关心文件变化）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、协商缓存（关心文件变化）"}},[a._v("#")]),a._v(" 2、协商缓存（关心文件变化）")]),a._v(" "),t("p",[a._v("向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；另外协商缓存需要与cache-control共同使用。")]),a._v(" "),t("h4",{attrs:{id:"相关header-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关header-2"}},[a._v("#")]),a._v(" 相关header:")]),a._v(" "),t("ul",[t("li",[a._v("Last-Modified和If-Modified-Since")])]),a._v(" "),t("p",[a._v("当第一次请求资源时，服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("客户端会为资源标记上该信息，下次再次请求时，会把Last-Modified附带在请求报文头部的If-Modified-Since字段里面，一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码，内容为空，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回200状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个304响应比一个静态资源通常小得多，这样就节省了网络带宽。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://img2.mukewang.com/5d42f513000133fd05000441.jpg",alt:"image"}})]),a._v(" "),t("p",[a._v("但last-modified 存在一些缺点：")]),a._v(" "),t("p",[a._v("A.某些服务端不能获取精确的修改时间")]),a._v(" "),t("p",[a._v("B.文件修改时间改了，但文件内容却没有变")]),a._v(" "),t("p",[a._v("C.1s内改变很多次，文件修改时间没变，但文件内容变了")]),a._v(" "),t("p",[a._v("既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？"),t("strong",[a._v("ETag和If-None-Match")])]),a._v(" "),t("ul",[t("li",[a._v("ETag和If-None-Match")])]),a._v(" "),t("p",[a._v("Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://img4.mukewang.com/5d42f5190001a5b105000245.jpg",alt:"image"}})]),a._v(" "),t("p",[a._v("两者之间对比：")]),a._v(" "),t("p",[a._v("A.首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。")]),a._v(" "),t("p",[a._v("B. 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。")]),a._v(" "),t("p",[a._v("C. 第三在优先级上，服务器校验优先考虑Etag。")]),a._v(" "),t("h2",{attrs:{id:"二、缓存机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、缓存机制"}},[a._v("#")]),a._v(" 二、缓存机制")]),a._v(" "),t("p",[a._v("强缓存优先于协商缓存进行，若强缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存。主要过程如下：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://img1.mukewang.com/5d42f51e0001717205000452.jpg",alt:"image"}})]),a._v(" "),t("h2",{attrs:{id:"三、用户行为对浏览器缓存的影响"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、用户行为对浏览器缓存的影响"}},[a._v("#")]),a._v(" 三、用户行为对浏览器缓存的影响")]),a._v(" "),t("ul",[t("li",[a._v("地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；")]),a._v(" "),t("li",[a._v("F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断；")]),a._v(" "),t("li",[a._v("ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。")])])])}),[],!1,null,null,null);e.default=s.exports}}]);