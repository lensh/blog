(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{493:function(t,v,a){"use strict";a.r(v);var e=a(62),_=Object(e.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"http三次握手四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http三次握手四次挥手"}},[t._v("#")]),t._v(" http三次握手四次挥手")]),t._v(" "),a("h2",{attrs:{id:"一、网络协议分层-经典五层模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、网络协议分层-经典五层模型"}},[t._v("#")]),t._v(" 一、网络协议分层--经典五层模型")]),t._v(" "),a("p",[t._v("物理层：定义物理设备之间如何传输数据")]),t._v(" "),a("p",[t._v("数据链路层：在通信的实体间建立数据链路链接")]),t._v(" "),a("p",[t._v("网络层：为数据在节点之间的传输创建逻辑链路")]),t._v(" "),a("p",[t._v("传输层：向用户提供可靠的端到端的服务，传输层通过封装向高层屏蔽了下层数据通信的细节")]),t._v(" "),a("p",[t._v("应用层：为应用软件提供了很多服务，构建于tcp协议之上，屏蔽了网络传输相关的细节")]),t._v(" "),a("h2",{attrs:{id:"二、tcp三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、tcp三次握手"}},[t._v("#")]),t._v(" 二、TCP三次握手")]),t._v(" "),a("p",[t._v("前置：")]),t._v(" "),a("p",[t._v("1、Http请求是基于Tcp connection这个链接的")]),t._v(" "),a("p",[t._v("2、位码即tcp标志位,有6种标示:")]),t._v(" "),a("p",[t._v("SYN(synchronous建立连接) 、ACK(acknowledgement 确认)、 PSH(push传送)")]),t._v(" "),a("p",[t._v("FIN(finish结束)、RST(reset重置)、 URG(urgent紧急)")]),t._v(" "),a("p",[t._v("Sequence number(顺序号码)")]),t._v(" "),a("p",[t._v("Acknowledge number(确认号码)")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://blog.chinaunix.net/attachment/201304/8/22312037_1365405910EROI.png",alt:"image"}})]),t._v(" "),a("h3",{attrs:{id:"第一次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一次握手"}},[t._v("#")]),t._v(" 第一次握手")]),t._v(" "),a("p",[t._v("客户端向服务器发出连接请求报文，这时报文首部中的同部位SYN=1，同时随机生成初始序列号 seq=x，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状\n态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。这个三次握手中的开始。表示客户端想要和服务端建立连接。")]),t._v(" "),a("h3",{attrs:{id:"第二次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二次握手"}},[t._v("#")]),t._v(" 第二次握手")]),t._v(" "),a("p",[t._v("TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己随机初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。这个报文带有SYN(建立连接)和ACK(确认)标志，询问客户端是否准备好。")]),t._v(" "),a("h3",{attrs:{id:"第三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第三次握手"}},[t._v("#")]),t._v(" 第三次握手")]),t._v(" "),a("p",[t._v("TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。")]),t._v(" "),a("p",[t._v("TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。这里客户端表示我已经准备好。")]),t._v(" "),a("p",[a("strong",[t._v("注：为什么要采用三次握手，两次不行吗？")])]),t._v(" "),a("p",[t._v("举例：已失效的连接请求报文段。")]),t._v(" "),a("p",[t._v("client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server，本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会向client发出确认的报文，表示同意连接。假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求，但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。")]),t._v(" "),a("h2",{attrs:{id:"三、tcp数据的传输过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、tcp数据的传输过程"}},[t._v("#")]),t._v(" 三、TCP数据的传输过程")]),t._v(" "),a("h3",{attrs:{id:"正常情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#正常情况"}},[t._v("#")]),t._v(" 正常情况")]),t._v(" "),a("p",[t._v("建立连接后，两台主机就可以相互传输数据了。如下图所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/blog/images/network-4-2.png",alt:"image"}})]),t._v(" "),a("p",[t._v("1）主机A初始seq为1200,滑动窗体为100,向主机B传递数据的过程。")]),t._v(" "),a("p",[t._v("2）假设主机B在完全成功接收数据的基础上,那么主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。因此按如下的公式确认 Ack 号：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  Ack号 = Seq号 + 传递的字节数 + 1 （这是在完全接受成功的情况下）\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("3）主机A获得B传来的ack(1301)后,开始发送seq为1301,滑动窗体为100的数据。")]),t._v(" "),a("p",[t._v("......")]),t._v(" "),a("h3",{attrs:{id:"丢包情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#丢包情况"}},[t._v("#")]),t._v(" 丢包情况")]),t._v(" "),a("p",[t._v("与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。上面说了，主机B完全成功接收A发来的数据才是这样的,如果存在丢包该如何。")]),t._v(" "),a("p",[t._v("下面分析传输过程中数据包丢失的情况，如下图所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/blog/images/network-4-3.png",alt:"image"}})]),t._v(" "),a("p",[t._v("上图表示通过 Seq 1301数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301的ACK确认，因此尝试重传数据。为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK包，那么定时器超时，数据包会重传。")]),t._v(" "),a("h2",{attrs:{id:"四、tcp四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、tcp四次挥手"}},[t._v("#")]),t._v(" 四、TCP四次挥手")]),t._v(" "),a("p",[a("img",{attrs:{src:"/blog/images/network-4-4.png",alt:"image"}})]),t._v(" "),a("h3",{attrs:{id:"第一次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一次挥手"}},[t._v("#")]),t._v(" 第一次挥手")]),t._v(" "),a("p",[t._v("TCP发送一个FIN(结束)，用来关闭客户到服务端的连接。客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。")]),t._v(" "),a("h3",{attrs:{id:"第二次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二次挥手"}},[t._v("#")]),t._v(" 第二次挥手")]),t._v(" "),a("p",[t._v("服务端收到这个FIN，他发回一个ACK(确认)，确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。")]),t._v(" "),a("p",[t._v("客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。")]),t._v(" "),a("h3",{attrs:{id:"第三次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第三次挥手"}},[t._v("#")]),t._v(" 第三次挥手")]),t._v(" "),a("p",[t._v("服务端发送一个FIN(结束)到客户端，服务端关闭客户端的连接。服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，")]),t._v(" "),a("p",[t._v("此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。")]),t._v(" "),a("h3",{attrs:{id:"第四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第四次挥手"}},[t._v("#")]),t._v(" 第四次挥手")]),t._v(" "),a("p",[t._v("客户端发送ACK(确认)报文确认，并将确认的序号+1，这样关闭完成。客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。")]),t._v(" "),a("p",[t._v("注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。")]),t._v(" "),a("p",[t._v("服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。")]),t._v(" "),a("p",[a("strong",[t._v("思考：那么为什么是4次挥手呢？")])]),t._v(" "),a("p",[t._v("为了确保数据能够完成传输。")]),t._v(" "),a("p",[t._v("关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。")]),t._v(" "),a("p",[t._v("可能有人会有疑问，tcp我握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢.")]),t._v(" "),a("p",[t._v('因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步挥手。')]),t._v(" "),a("p",[a("strong",[t._v("思考:客户端突然挂掉了怎么办？")])]),t._v(" "),a("p",[t._v("正常连接时，客户端突然挂掉了，如果没有措施处理这种情况，那么就会出现客户端和服务器端出现长时期的空闲。解决办法是在服务器端设置保活计时器，每当服务器收到客户端的消息，就将计时器复位。超时时间通常设置为2小时。若服务器超过2小时没收到客户的信息，他就发送探测报文段。若发送了10个探测报文段，每一个相隔75秒，还没有响应就认为客户端出了故障，因而终止该连接。")]),t._v(" "),a("p",[a("strong",[t._v("如果A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？")])]),t._v(" "),a("p",[t._v("因为B会在重启之后进入tcp状态机的listen状态，只要当a重新发送一个数据包（无论是syn包或者是应用数据），b端应该会主动发送一个带rst位的重置包来进行连接重置，所以a应该在syn_sent状态。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/qdhxhz/p/8470997.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考"),a("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=_.exports}}]);